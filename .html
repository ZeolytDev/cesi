<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Empire - Connected Edition</title>
    <style>
        /* --- CSS VARIABLES & RESET --- */
        :root {
            --bg: #121212; --panel: #1e1e1e; --accent: #bb86fc;
            --gold: #ffd700; --red: #cf6679; --green: #03dac6;
            --text: #ffffff; --text-sec: #b0b0b0;
            --panel-soft: #25293a;
            --border-soft: rgba(187, 134, 252, 0.28);
        }

        body {
            margin: 0; padding: 0; font-family: 'Roboto', 'Segoe UI', sans-serif;
            background: radial-gradient(circle at top, #1f263c 0%, #121212 45%);
            color: var(--text);
            height: 100vh; overflow: hidden; user-select: none; display: flex; flex-direction: column;
        }

        /* --- TABS NAVIGATION --- */
        #tabs-bar {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0, 0, 0, 0.45); backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-soft); gap: 10px; z-index: 5;
        }
        .tabs-group { display: flex; flex-wrap: wrap; gap: 10px; }
        .tab-btn {
            background: #222837; color: var(--text-sec); border: 1px solid #444c61;
            padding: 10px 20px; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: 0.3s;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); box-shadow: 0 0 16px rgba(187, 134, 252, 0.45); }
        .tab-btn:hover:not(.active) { background: #31364b; color: white; }
        .tab-btn.logout { background: transparent; color: #ff8f9f; border-color: rgba(255, 143, 159, 0.6); }
        .tab-btn.logout:hover { background: rgba(255, 143, 159, 0.15); }
        .hidden { display: none !important; }

        /* --- SCREENS --- */
        .screen { display: none; width: 100%; height: 100%; flex: 1; }
        .screen.active { display: flex; }

        /* --- CLICKER LAYOUT --- */
        #game-layer { display: flex; width: 100%; height: 100%; transition: filter 0.5s ease; }
        .blurred { filter: blur(20px); pointer-events: none; }
        .game-area { flex: 6; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, #2f3855 0%, #121212 78%); position: relative; }
        .shop-area { flex: 4; background: linear-gradient(170deg, #1e1e2c 0%, #151723 100%); display: flex; flex-direction: column; border-left: 1px solid var(--border-soft); max-width: 450px; }

        /* --- GAME ELEMENTS --- */
        .header-stats { text-align: center; margin-bottom: 20px; z-index: 2; }
        #score { font-size: 4rem; font-weight: 800; color: var(--text); text-shadow: 0 0 20px rgba(187, 134, 252, 0.3); }
        #cps { color: var(--text-sec); font-size: 1.2rem; }
        .prestige-badge { background: linear-gradient(45deg, #FFD700, #FFA500); color: black; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 0.9rem; margin-top: 10px; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); display: inline-block; }
        #cookie { font-size: 200px; cursor: pointer; transition: transform 0.05s; filter: drop-shadow(0 0 30px rgba(0,0,0,0.5)); z-index: 2; }
        #cookie:active { transform: scale(0.95); }
        .goal-text { color: var(--red); font-weight: bold; margin-top: 20px; font-size: 1.1rem; }

        /* --- SHOP & ADMIN --- */
        .shop-header { padding: 20px; background: var(--panel-soft); border-bottom: 1px solid var(--border-soft); display: flex; justify-content: space-between; align-items: center; }
        .shop-content { flex: 1; overflow-y: auto; padding: 10px; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .shop-item { background: #2a3042; margin-bottom: 8px; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; transition: all 0.2s; }
        .shop-item:hover { transform: translateX(-4px); background: #333b52; border-color: var(--border-soft); }
        .item-info h4 { margin: 0; font-size: 1rem; color: var(--text); }
        .item-info p { margin: 4px 0 0; font-size: 0.75rem; color: var(--text-sec); }
        .item-cost { font-weight: bold; color: var(--gold); }
        .buy-btn { background: #202735; border: 1px solid #555; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; min-width: 80px; transition: 0.2s; }
        .can-buy { background: var(--green); color: black; border-color: var(--green); font-weight: bold; }
        .locked { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        #ascend-btn { width: 100%; padding: 20px; background: linear-gradient(45deg, #e94560, #c0392b); color: white; border: none; font-weight: bold; font-size: 1.2rem; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; display: none; }
        #ascend-btn:hover { filter: brightness(1.2); }
        .floater { position: absolute; font-size: 24px; font-weight: bold; color: white; pointer-events: none; animation: floatUp 1s ease-out forwards; }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
        .admin-panel { border-top: 1px solid var(--border-soft); padding: 12px; background: #1b2030; }
        .admin-panel h4 { margin: 0 0 8px; color: var(--gold); }
        .admin-panel input {
            width: 100%; padding: 9px; margin: 6px 0; border-radius: 6px;
            background: #111623; border: 1px solid #3c4560; color: #fff;
        }
        #admin-status { min-height: 20px; color: var(--text-sec); font-size: 0.85rem; margin-top: 6px; }

        /* --- MINIGAME CANVASES --- */
        .canvas-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #111; }
        canvas { border: 2px solid var(--accent); background: #000; box-shadow: 0 0 20px rgba(187,134,252,0.2); }
        .minigame-ui { text-align: center; margin-bottom: 15px; }
        .minigame-ui h2 { margin: 0; color: var(--accent); }
        .minigame-ui p { margin: 5px 0 0 0; color: var(--text-sec); }
        .warning-text { color: var(--red); font-weight: bold; font-size: 1.2rem; text-transform: uppercase; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }


        .relax-grid { display: grid; grid-template-columns: repeat(2, minmax(340px, 1fr)); gap: 18px; width: min(95vw, 900px); }
        .relax-card { background: #171c2a; border: 1px solid var(--border-soft); border-radius: 10px; padding: 12px; }
        .relax-card h3 { margin: 0 0 8px; color: var(--green); }
        .actions-row { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
        .memory-board {
            display:grid; grid-template-columns: repeat(10, 52px); gap:8px; justify-content:center;
            margin-top: 10px; max-height: 360px; overflow-y: auto; padding: 8px; background: #0d111d; border-radius: 10px; border: 1px solid #2f3855;
        }
        .memory-card { width:52px; height:52px; border-radius:8px; border:1px solid #495170; background:#26304a; color:#fff; font-size:24px; cursor:pointer; transition: transform .2s, background .2s; }
        .memory-card:hover { transform: translateY(-2px); }
        .memory-card.revealed, .memory-card.matched { background:#03dac6; color:#111; }
        .memory-card.matched { cursor:default; opacity:.85; }

        /* --- LOGIN MODAL --- */
        #login-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: rgba(6,8,14,0.8); z-index: 10; }
        .card { background: linear-gradient(170deg, #202434 0%, #161a28 100%); padding: 40px; border-radius: 14px; text-align: center; border: 1px solid var(--border-soft); width: 320px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35); }
        input { width: 90%; padding: 10px; margin: 10px 0; background: #121726; border: 1px solid #39415a; color: white; border-radius: 5px; }
        .btn-main { width: 100%; padding: 12px; background: var(--accent); color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="login-modal">
        <div class="card">
            <h2 style="color: var(--accent)">Swarm Login</h2>
            <p id="login-status" style="color: var(--text-sec); font-size: 0.9rem; margin-bottom: 10px;">Checking connection...</p>
            <input type="text" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <button class="btn-main" onclick="manualLogin()">ENTER SYSTEM</button>
        </div>
    </div>

    <div id="tabs-bar" class="hidden">
        <div class="tabs-group">
            <button id="btn-clicker" class="tab-btn active" onclick="switchTab('screen-clicker', this)">Main Terminal</button>
            <button id="btn-tetris" class="tab-btn hidden" onclick="switchTab('screen-tetris', this)">Tetris (Score: <span id="tetris-high">0</span>/1000)</button>
            <button id="btn-memory" class="tab-btn hidden" onclick="switchTab('screen-memory', this)">Memory 50 cartes</button>
            <button id="btn-flappy" class="tab-btn hidden" onclick="switchTab('screen-flappy', this)">Flappy (Score: <span id="flappy-high">0</span>/20)</button>
            <button id="btn-final" class="tab-btn hidden" onclick="switchTab('screen-final', this)">Swarm Survival</button>
            <button id="btn-relax" class="tab-btn" onclick="switchTab('screen-relax', this)">Espace d√©tente</button>
        </div>
        <button class="tab-btn logout" onclick="logout()">Se d√©connecter</button>
    </div>

    <div id="screen-clicker" class="screen active">
        <div id="game-layer" class="blurred">
            <div class="game-area">
                <div class="header-stats">
                    <div id="score">0</div>
                    <div id="cps">0 Cookies / Sec</div>
                    <div id="prestige-display" class="prestige-badge hidden">
                        MULTIPLIER: x<span id="mult-val">1</span>
                    </div>
                    <div id="tetris-goal" class="goal-text">Goal: Reach 1,000,000,000 Qa Cookies to unlock the Arcade!</div>
                </div>
                <div id="cookie" onclick="clickCookie(event)">üç™</div>
            </div>

            <div class="shop-area">
                <div class="shop-header">
                    <h3>MARKETPLACE</h3>
                    <small id="wallet">0</small>
                </div>
                <div class="shop-content" id="shop-list"></div>
                <div id="admin-panel" class="admin-panel hidden">
                    <h4>ADMIN - Create account</h4>
                    <input id="admin-email" placeholder="email">
                    <input id="admin-password" type="password" placeholder="password (min 8)">
                    <input id="admin-firstname" placeholder="first name (optional)">
                    <input id="admin-lastname" placeholder="last name (optional)">
                    <button class="buy-btn can-buy" style="width:100%;margin-top:6px" onclick="adminCreateUser()">Create user</button>
                    <div id="admin-status"></div>
                </div>
                <button id="ascend-btn" onclick="ascend()">
                    ‚ö†Ô∏è SYSTEM REBOOT ‚ö†Ô∏è<br>
                    <span style="font-size: 0.7rem; opacity: 0.8">Reset Cookies for x2 Income</span>
                </button>
            </div>
        </div>
    </div>

    <div id="screen-tetris" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>TETRIS</h2>
                <p>Arrow keys to move/rotate. Down to drop. Reach 1000 to unlock next module.</p>
                <h3 style="color:var(--gold)">Score: <span id="tetris-score">0</span></h3>
            </div>
            <canvas id="tetris-canvas" width="240" height="400"></canvas>
        </div>
    </div>


    <div id="screen-memory" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>MEMORY - 50 CARTES</h2>
                <p>Trouve les 25 paires d'√©mojis pour d√©verrouiller Flappy Bird.</p>
                <h3 style="color:var(--gold)">Paires: <span id="memory-matched">0</span>/25</h3>
                <h3>Essais: <span id="memory-attempts">0</span></h3>
            </div>
            <div id="memory-board" class="memory-board"></div>
        </div>
    </div>

    <div id="screen-flappy" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>FLAPPY BIRD</h2>
                <p>Click or Spacebar to jump. Reach 20 to unlock the final challenge.</p>
                <h3 style="color:var(--gold)">Score: <span id="flappy-score">0</span></h3>
            </div>
            <canvas id="flappy-canvas" width="320" height="480"></canvas>
        </div>
    </div>

    <div id="screen-relax" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>ESPACE D√âTENTE üé∞üÉè</h2>
                <p>Roulette anim√©e + Blackjack anim√©.</p>
                <h3 style="color:var(--gold)">Jetons: <span id="slot-tokens">50</span></h3>
            </div>
            <div class="relax-grid">
                <div class="relax-card">
                    <h3>Roulette</h3>
                    <p id="slot-result">Pr√™t √† lancer</p>
                    <canvas id="slot-canvas" width="360" height="220"></canvas>
                    <div class="actions-row">
                        <button class="buy-btn can-buy" onclick="spinSlotMachine()">Lancer roulette (-1)</button>
                    </div>
                </div>
                <div class="relax-card">
                    <h3>Blackjack</h3>
                    <p id="blackjack-result">Lance une partie.</p>
                    <canvas id="blackjack-canvas" width="360" height="220"></canvas>
                    <div class="actions-row">
                        <button class="buy-btn" onclick="startBlackjackRound()">Nouvelle main (-2)</button>
                        <button class="buy-btn" onclick="blackjackHit()">Hit</button>
                        <button class="buy-btn" onclick="blackjackStand()">Stand</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-final" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>SWARM SURVIVAL</h2>
                <p class="warning-text">‚ö†Ô∏è WIN OR GO BACK TO THE BEGINNING ‚ö†Ô∏è</p>
                <p>Move your mouse to control the blue square. DODGE the red swarm. Survive 30 seconds.</p>
                <h3 style="color:var(--gold)">Time: <span id="dodge-score">0</span>s / 30s</h3>
            </div>
            <canvas id="dodge-canvas" width="600" height="400"></canvas>
        </div>
    </div>

    <script src="/config.js"></script>
    <script>
        const BASE_URL = (window.__APP_CONFIG__ && window.__APP_CONFIG__.API_BASE_URL) || "http://192.168.100.91:3000"; 
        let currentUser = null;
        let saveLoopStarted = false;

        const buildingDefs = [
            { id: 'cursor',  name: 'Better Mouse',   baseCost: 15,      val: 1,      type: 'click' },
            { id: 'grandma', name: 'Grandma',        baseCost: 100,     val: 5,      type: 'auto' },
            { id: 'farm',    name: 'Cookie Farm',    baseCost: 1100,    val: 15,     type: 'auto' },
            { id: 'mine',    name: 'Cookie Mine',    baseCost: 12000,   val: 50,     type: 'auto' },
            { id: 'factory', name: 'Factory',        baseCost: 130000,  val: 150,    type: 'auto' },
            { id: 'bank',    name: 'Bank',           baseCost: 1400000, val: 500,    type: 'auto' },
            { id: 'temple',  name: 'Temple',         baseCost: 20000000,val: 1500,   type: 'auto' },
            { id: 'wiz',     name: 'Wizard Tower',   baseCost: 330000000, val: 5000, type: 'auto' },
            { id: 'ship',    name: 'Shipment',       baseCost: 5100000000, val: 20000, type: 'auto' },
            { id: 'alchemy', name: 'Alchemy Lab',    baseCost: 75000000000, val: 100000, type: 'auto' },
            { id: 'portal',  name: 'Portal',         baseCost: 1000000000000, val: 500000, type: 'auto' },
            { id: 'time',    name: 'Time Machine',   baseCost: 14000000000000, val: 2000000, type: 'auto' }
        ];

        let gameState = {
            cookies: 0, clickBase: 1, autoBase: 0, multiplier: 1, buildings: {},
            unlockedTetris: false, unlockedMemory: false, unlockedFlappy: false, unlockedFinal: false,
            memorySolved: false, memoryAttempts: 0,
            tetrisHigh: 0, flappyHigh: 0, slotTokens: 50
        };

        buildingDefs.forEach(b => gameState.buildings[b.id] = 0);

        // --- AUTH & NETWORK ---
        window.onload = async function() {
            try {
                const response = await fetch(`${BASE_URL}/api/auth/me`, { method: "GET", credentials: "include" });
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('login-status').innerText = "Session found! Loading...";
                    await startGame(data);
                } else { document.getElementById('login-status').innerText = "Please log in."; }
            } catch (error) { document.getElementById('login-status').innerText = "Cannot connect to server."; }
        };

        async function manualLogin() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const statusText = document.getElementById('login-status');
            if (!email || !pass) return statusText.innerText = "Please enter email and password.";
            statusText.innerText = "Authenticating...";

            try {
                const response = await fetch(`${BASE_URL}/api/auth/login`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ email: email.trim(), password: pass })
                });
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.error || "Invalid credentials");
                }
                await startGame(await response.json());
            } catch (error) { statusText.innerText = `Login Failed: ${error.message || "UNKNOWN"}`; }
        }

        async function logout() {
            try {
                await fetch(`${BASE_URL}/api/auth/logout`, { method: 'POST', credentials: 'include' });
            } catch (error) {
                console.warn('Logout request failed, clearing local session only.');
            }

            currentUser = null;
            document.getElementById('login-modal').classList.remove('hidden');
            document.getElementById('game-layer').classList.add('blurred');
            document.getElementById('tabs-bar').classList.add('hidden');
            document.getElementById('admin-panel').classList.add('hidden');
            document.getElementById('login-status').innerText = "Session closed. Please log in.";
        }

        async function startGame(data) {
            currentUser = data?.user || null;
            await loadGameState();
            
            document.getElementById('login-modal').classList.add('hidden');
            document.getElementById('game-layer').classList.remove('blurred');
            document.getElementById('tabs-bar').classList.remove('hidden');
            document.getElementById('admin-panel').classList.toggle('hidden', currentUser?.role !== "ADMIN");
            
            if (gameState.multiplier > 1) {
                document.getElementById('prestige-display').classList.remove('hidden');
                document.getElementById('mult-val').innerText = gameState.multiplier;
            }

            checkUnlocks();
            renderShop();
            updateUI();
            
            if (!saveLoopStarted) {
                setInterval(autoLoop, 1000);
                setInterval(saveGame, 10000); 
                saveLoopStarted = true;
                
                requestAnimationFrame(tetrisLoop);
                requestAnimationFrame(flappyLoop);
                requestAnimationFrame(dodgeLoop);
            }
            initMemoryGame();
        }

        async function loadGameState() {
            try {
                const response = await fetch(`${BASE_URL}/api/game/state`, { method: "GET", credentials: "include" });
                if (!response.ok) return;
                const data = await response.json();
                if (!data?.gameState) return;
                
                gameState.cookies = Number(data.gameState.cookies ?? 0);
                gameState.clickBase = Number(data.gameState.clickBase ?? 1);
                gameState.autoBase = Number(data.gameState.autoBase ?? 0);
                gameState.multiplier = Number(data.gameState.multiplier ?? 1);
                gameState.buildings = data.gameState.buildings || {};
                
                gameState.unlockedTetris = data.gameState.unlockedTetris || false;
                gameState.unlockedMemory = data.gameState.unlockedMemory || false;
                gameState.unlockedFlappy = data.gameState.unlockedFlappy || false;
                gameState.unlockedFinal = data.gameState.unlockedFinal || false;
                gameState.memorySolved = data.gameState.memorySolved || false;
                gameState.memoryAttempts = Number(data.gameState.memoryAttempts ?? 0);
                gameState.tetrisHigh = data.gameState.tetrisHigh || 0;
                gameState.flappyHigh = data.gameState.flappyHigh || 0;
                gameState.slotTokens = Number(data.gameState.slotTokens ?? 50);

                buildingDefs.forEach(b => { if (typeof gameState.buildings[b.id] !== "number") gameState.buildings[b.id] = 0; });
            } catch (error) { console.error("Failed to load game state"); }
        }

        async function saveGame() {
            if (!currentUser) return;
            try {
                await fetch(`${BASE_URL}/api/game/save`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ state: gameState })
                });
            } catch (error) {}
        }

        async function adminCreateUser() {
            if (!currentUser || currentUser.role !== "ADMIN") return;
            const status = document.getElementById("admin-status");
            const email = document.getElementById("admin-email").value.trim();
            const password = document.getElementById("admin-password").value;
            const firstName = document.getElementById("admin-firstname").value.trim();
            const lastName = document.getElementById("admin-lastname").value.trim();

            status.innerText = "Creating...";
            try {
                const response = await fetch(`${BASE_URL}/api/admin/users`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify({
                        email,
                        password,
                        ...(firstName ? { firstName } : {}),
                        ...(lastName ? { lastName } : {})
                    })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data.error || "CREATE_FAILED");
                }
                status.style.color = "var(--green)";
                status.innerText = `Created: ${data.user.email}`;
                document.getElementById("admin-email").value = "";
                document.getElementById("admin-password").value = "";
                document.getElementById("admin-firstname").value = "";
                document.getElementById("admin-lastname").value = "";
            } catch (error) {
                status.style.color = "var(--red)";
                status.innerText = `Failed: ${error.message || "UNKNOWN"}`;
            }
        }

        // --- TAB LOGIC ---
        let currentActiveTab = 'screen-clicker';
        function switchTab(screenId, btnElement) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            btnElement.classList.add('active');
            currentActiveTab = screenId;
            if (screenId === 'screen-memory') renderMemoryBoard();
        }

        function checkUnlocks() {
            // 1e24 = 1 Septillion = 1,000,000,000 Quadrillion (Qa)
            if (gameState.cookies >= 1e24) {
                gameState.unlockedTetris = true;
                document.getElementById('tetris-goal').classList.add('hidden');
            } else if (!gameState.unlockedTetris) {
                document.getElementById('tetris-goal').classList.remove('hidden');
            }

            if (gameState.tetrisHigh >= 1000) gameState.unlockedMemory = true;
            if (gameState.memorySolved) gameState.unlockedFlappy = true;
            if (gameState.flappyHigh >= 20) gameState.unlockedFinal = true;

            if (gameState.unlockedTetris) document.getElementById('btn-tetris').classList.remove('hidden');
            else document.getElementById('btn-tetris').classList.add('hidden');
            
            if (gameState.unlockedMemory) document.getElementById('btn-memory').classList.remove('hidden');
            else document.getElementById('btn-memory').classList.add('hidden');

            if (gameState.unlockedFlappy) document.getElementById('btn-flappy').classList.remove('hidden');
            else document.getElementById('btn-flappy').classList.add('hidden');
            
            if (gameState.unlockedFinal) document.getElementById('btn-final').classList.remove('hidden');
            else document.getElementById('btn-final').classList.add('hidden');

            document.getElementById('tetris-high').innerText = gameState.tetrisHigh;
            document.getElementById('flappy-high').innerText = gameState.flappyHigh;
            document.getElementById('slot-tokens').innerText = gameState.slotTokens;
        }

        // --- CORE CLICKER ---
        function clickCookie(e) {
            let amount = gameState.clickBase * gameState.multiplier;
            gameState.cookies += amount;
            spawnFloater(e.clientX, e.clientY, "+" + formatNumber(amount));
            updateUI();
        }

        function autoLoop() {
            if (gameState.autoBase > 0) {
                gameState.cookies += (gameState.autoBase * gameState.multiplier);
                updateUI();
            }
        }

        function ascend() {
            if (gameState.cookies < 10000) return;
            if(!confirm("REBOOT SYSTEM? \n\nYou lose cookies & buildings. Gain permanent x2 Income.")) return;
            gameState.multiplier *= 2; gameState.cookies = 0; gameState.clickBase = 1; gameState.autoBase = 0;
            buildingDefs.forEach(b => gameState.buildings[b.id] = 0);
            document.getElementById('prestige-display').classList.remove('hidden');
            document.getElementById('mult-val').innerText = gameState.multiplier;
            document.getElementById('ascend-btn').style.display = 'none';
            renderShop(); updateUI(); saveGame(); 
        }

        function buy(id) {
            const item = buildingDefs.find(b => b.id === id);
            const cost = getCost(item);
            if (gameState.cookies >= cost) {
                gameState.cookies -= cost; gameState.buildings[id]++;
                if (item.type === 'click') gameState.clickBase += item.val;
                if (item.type === 'auto')  gameState.autoBase += item.val;
                updateUI(); renderShop(); 
            }
        }

        function getCost(item) { return Math.floor(item.baseCost * Math.pow(1.15, gameState.buildings[item.id])); }

        function renderShop() {
            const list = document.getElementById('shop-list');
            list.innerHTML = ""; 
            buildingDefs.forEach(item => {
                const cost = getCost(item); const count = gameState.buildings[item.id];
                const canAfford = gameState.cookies >= cost;
                list.innerHTML += `
                    <div class="shop-item">
                        <div class="item-info">
                            <h4>${item.name} <span style="color:#666; font-size:0.8em">x${count}</span></h4>
                            <p>+${formatNumber(item.val * gameState.multiplier)} ${item.type === 'click' ? 'Click' : '/ sec'}</p>
                            <div class="item-cost">üç™ ${formatNumber(cost)}</div>
                        </div>
                        <button class="buy-btn ${canAfford ? 'can-buy' : 'locked'}" onclick="buy('${item.id}')">BUY</button>
                    </div>
                `;
            });
        }

        function updateUI() {
            document.getElementById('score').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('wallet').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('cps').innerText = formatNumber(gameState.autoBase * gameState.multiplier) + " / Sec";
            document.getElementById('ascend-btn').style.display = gameState.cookies >= 10000 ? 'block' : 'none';

            const buttons = document.querySelectorAll('.buy-btn');
            buildingDefs.forEach((item, i) => {
                if(buttons[i]) buttons[i].className = `buy-btn ${gameState.cookies >= getCost(item) ? 'can-buy' : 'locked'}`;
            });
            checkUnlocks();
        }

        // --- UPDATED NUMBER FORMATTER ---
        function formatNumber(num) {
            if (num >= 1e27) return (num / 1e27).toFixed(2) + 'Oc'; // Octillion
            if (num >= 1e24) return (num / 1e24).toFixed(2) + 'Sp'; // Septillion (1,000,000,000 Qa)
            if (num >= 1e21) return (num / 1e21).toFixed(2) + 'Sx'; // Sextillion
            if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillion
            if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Qa'; // Quadrillion
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillion
            if (num >= 1e9)  return (num / 1e9).toFixed(2) + 'B';   // Billion
            if (num >= 1e6)  return (num / 1e6).toFixed(2) + 'M';   // Million
            if (num >= 1e3)  return (num / 1e3).toFixed(2) + 'k';   // Thousand
            return Math.floor(num).toString();
        }

        function spawnFloater(x, y, text) {
            const el = document.createElement('div');
            el.innerText = text; el.className = 'floater';
            el.style.left = (x - 20) + "px"; el.style.top = (y - 50) + "px";
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // ==========================================
        // MINIGAME 1: TETRIS
        // ==========================================
        const tCanv = document.getElementById('tetris-canvas');
        const tCtx = tCanv.getContext('2d');
        const COLS = 12, ROWS = 20, BLOCK = 20;
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let piece = null, tScore = 0, lastDrop = Date.now();
        const shapes = [ [],
            [[1,1,1,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]],
            [[1,1],[1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]]
        ];
        const colors = [null, '#00ffff', '#0000ff', '#ffa500', '#ffff00', '#00ff00', '#800080', '#ff0000'];

        function spawnTetrisPiece() {
            const type = Math.floor(Math.random() * 7) + 1;
            piece = { matrix: shapes[type], x: 4, y: 0, type: type };
            if (collide(board, piece)) { board.forEach(row => row.fill(0)); tScore = 0; } // Game Over
        }
        
        function collide(b, p) {
            for (let y = 0; y < p.matrix.length; ++y) {
                for (let x = 0; x < p.matrix[y].length; ++x) {
                    if (p.matrix[y][x] && (b[y + p.y] && b[y + p.y][x + p.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(b, p) {
            p.matrix.forEach((row, y) => row.forEach((val, x) => { if (val) b[y + p.y][x + p.x] = p.type; }));
        }

        function clearLines() {
            outer: for (let y = ROWS - 1; y >= 0; --y) {
                for (let x = 0; x < COLS; ++x) if (board[y][x] === 0) continue outer;
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row); ++y; tScore += 100;
                if(tScore > gameState.tetrisHigh) { gameState.tetrisHigh = tScore; checkUnlocks(); }
                document.getElementById('tetris-score').innerText = tScore;
            }
        }

        function tetrisLoop() {
            if (currentActiveTab === 'screen-tetris') {
                if (!piece) spawnTetrisPiece();
                if (Date.now() - lastDrop > 500) {
                    piece.y++;
                    if (collide(board, piece)) { piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); }
                    lastDrop = Date.now();
                }
                tCtx.fillStyle = '#000'; tCtx.fillRect(0,0, tCanv.width, tCanv.height);
                drawMatrix(board, 0, 0);
                if (piece) drawMatrix(piece.matrix, piece.x, piece.y);
            }
            requestAnimationFrame(tetrisLoop);
        }

        function drawMatrix(matrix, offsetX, offsetY) {
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val !== 0) {
                        tCtx.fillStyle = colors[val];
                        tCtx.fillRect((x + offsetX) * BLOCK, (y + offsetY) * BLOCK, BLOCK-1, BLOCK-1);
                    }
                });
            });
        }

        document.addEventListener('keydown', e => {
            if (currentActiveTab !== 'screen-tetris' || !piece) return;
            if (e.key === 'ArrowLeft') { piece.x--; if(collide(board, piece)) piece.x++; }
            if (e.key === 'ArrowRight') { piece.x++; if(collide(board, piece)) piece.x--; }
            if (e.key === 'ArrowDown') { piece.y++; if(collide(board, piece)){ piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); } }
            if (e.key === 'ArrowUp') {
                const rot = piece.matrix[0].map((val, index) => piece.matrix.map(row => row[index]).reverse());
                const prev = piece.matrix; piece.matrix = rot;
                if (collide(board, piece)) piece.matrix = prev;
            }
        });

        // ==========================================
        // MINIGAME 2: FLAPPY BIRD
        // ==========================================
        const fCanv = document.getElementById('flappy-canvas');
        const fCtx = fCanv.getContext('2d');
        let bird = { y: 240, v: 0, size: 20 }, pipes = [], fFrames = 0, fScore = 0;
        let explosion = { active: false, x: 0, y: 0, life: 0, particles: [] };

        function jump(e) { if(currentActiveTab === 'screen-flappy') { bird.v = -6; if(e) e.preventDefault(); } }
        document.addEventListener('keydown', e => { if(e.code === 'Space') jump(e); });
        fCanv.addEventListener('mousedown', jump);

        function triggerExplosion(x, y) {
            explosion = {
                active: true,
                x,
                y,
                life: 25,
                particles: Array.from({ length: 16 }, () => ({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: Math.random() * 4 + 2
                }))
            };
        }

        function resetFlappy() {
            fScore = 0;
            bird.y = 240;
            bird.v = 0;
            pipes = [];
            fFrames = 0;
            document.getElementById('flappy-score').innerText = '0';
        }

        function flappyLoop() {
            if (currentActiveTab === 'screen-flappy') {
                bird.v += 0.3; bird.y += bird.v; 
                if(fFrames % 90 === 0) pipes.push({ x: 320, gap: Math.random()*200 + 50, passed: false });
                
                fCtx.fillStyle = '#000'; fCtx.fillRect(0,0, 320, 480);
                fCtx.font = '22px sans-serif';
                fCtx.fillText('‚úàÔ∏è', 50, bird.y + bird.size);

                pipes.forEach((p, i) => {
                    p.x -= 2;
                    fCtx.fillStyle = '#03dac6';
                    fCtx.fillRect(p.x, 0, 40, p.gap); 
                    fCtx.fillRect(p.x, p.gap + 120, 40, 480); 
                    
                    if ((50 < p.x + 40 && 50 + bird.size > p.x && (bird.y < p.gap || bird.y + bird.size > p.gap + 120)) || bird.y > 480 || bird.y < -bird.size) {
                        triggerExplosion(60, bird.y + bird.size / 2);
                        resetFlappy();
                    }
                    if (!p.passed && p.x + 40 < 50) {
                        p.passed = true;
                        fScore++; document.getElementById('flappy-score').innerText = fScore;
                        if(fScore > gameState.flappyHigh) { gameState.flappyHigh = fScore; checkUnlocks(); }
                    }
                });
                pipes = pipes.filter(p => p.x > -40);

                if (explosion.active) {
                    explosion.particles.forEach(part => {
                        part.x += part.vx;
                        part.y += part.vy;
                        part.size *= 0.94;
                        fCtx.fillStyle = '#ff6b35';
                        fCtx.fillRect(part.x, part.y, Math.max(part.size, 1), Math.max(part.size, 1));
                    });
                    explosion.life--;
                    if (explosion.life <= 0) explosion.active = false;
                }
                fFrames++;
            }
            requestAnimationFrame(flappyLoop);
        }

        // ==========================================
        // MINIGAME 2.5: MEMORY (50 CARDS)
        // ==========================================
        const memoryEmojis = ['üêù','üê±','üê∂','ü¶ä','üêº','üê∏','ü¶Å','üêµ','üêô','ü¶Ñ','üêß','üê¢','üê≥','ü¶ã','üåà','‚≠ê','üî•','üçÄ','üéØ','‚ö°','üçï','üç©','üéà','üöÄ','üéÆ'];
        let memoryCards = [];
        let memoryRevealed = [];
        let memoryMatched = 0;

        function initMemoryGame() {
            const deck = [...memoryEmojis, ...memoryEmojis]
                .map((emoji, i) => ({ id: i, emoji, matched: false }))
                .sort(() => Math.random() - 0.5);
            memoryCards = deck;
            memoryRevealed = [];
            memoryMatched = gameState.memorySolved ? 25 : 0;
            if (gameState.memorySolved) memoryCards.forEach(c => c.matched = true);
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            document.getElementById('memory-matched').innerText = memoryMatched;
            renderMemoryBoard();
        }

        function renderMemoryBoard() {
            const board = document.getElementById('memory-board');
            if (!memoryCards.length) initMemoryGame();
            board.innerHTML = '';
            memoryCards.forEach((card, index) => {
                const btn = document.createElement('button');
                const shown = card.matched || memoryRevealed.includes(index);
                btn.className = `memory-card ${shown ? 'revealed' : ''} ${card.matched ? 'matched' : ''}`;
                btn.innerText = shown ? card.emoji : '‚ùî';
                btn.onclick = () => flipMemoryCard(index);
                if (card.matched) btn.disabled = true;
                board.appendChild(btn);
            });
        }

        function flipMemoryCard(index) {
            const card = memoryCards[index];
            if (!card || card.matched || memoryRevealed.includes(index) || memoryRevealed.length === 2 || gameState.memorySolved) return;
            memoryRevealed.push(index);
            renderMemoryBoard();
            if (memoryRevealed.length < 2) return;
            gameState.memoryAttempts += 1;
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            const [a, b] = memoryRevealed;
            if (memoryCards[a].emoji === memoryCards[b].emoji) {
                memoryCards[a].matched = true;
                memoryCards[b].matched = true;
                memoryMatched += 1;
                document.getElementById('memory-matched').innerText = memoryMatched;
                memoryRevealed = [];
                if (memoryMatched === 25) {
                    gameState.memorySolved = true;
                    gameState.unlockedFlappy = true;
                    checkUnlocks();
                    document.getElementById('slot-result').innerText = 'Memory termin√©, Flappy d√©verrouill√© ‚úÖ';
                }
                renderMemoryBoard();
                return;
            }
            setTimeout(() => { memoryRevealed = []; renderMemoryBoard(); }, 650);
        }

        // ==========================================
        // BONUS: ROULETTE + BLACKJACK (RELAX SPACE)
        // ==========================================
        const sCanv = document.getElementById('slot-canvas');
        const sCtx = sCanv.getContext('2d');
        const rouletteSlices = [
            { label: '-1', gain: 0, color: '#6b7280', weight: 45 },
            { label: '+1', gain: 2, color: '#2563eb', weight: 28 },
            { label: '+3', gain: 4, color: '#16a34a', weight: 18 },
            { label: '+8', gain: 9, color: '#f59e0b', weight: 7 },
            { label: 'JACKPOT', gain: 20, color: '#ef4444', weight: 2 }
        ];
        let rouletteAngle = 0;

        function weightedRoulettePick() {
            const total = rouletteSlices.reduce((acc, s) => acc + s.weight, 0);
            let roll = Math.random() * total;
            for (const slice of rouletteSlices) {
                roll -= slice.weight;
                if (roll <= 0) return slice;
            }
            return rouletteSlices[0];
        }

        function drawRoulette(pointerIndex = null) {
            sCtx.clearRect(0, 0, sCanv.width, sCanv.height);
            const cx = 120, cy = 110, r = 85;
            const sliceAngle = (Math.PI * 2) / rouletteSlices.length;
            rouletteSlices.forEach((slice, i) => {
                const start = rouletteAngle + i * sliceAngle;
                sCtx.beginPath(); sCtx.moveTo(cx, cy);
                sCtx.arc(cx, cy, r, start, start + sliceAngle);
                sCtx.closePath();
                sCtx.fillStyle = slice.color;
                sCtx.fill();
                sCtx.fillStyle = '#fff';
                sCtx.font = '12px sans-serif';
                sCtx.fillText(slice.label, cx + Math.cos(start + sliceAngle / 2) * 45 - 14, cy + Math.sin(start + sliceAngle / 2) * 45);
            });
            sCtx.fillStyle = '#fff';
            sCtx.beginPath();
            sCtx.moveTo(cx + r + 15, cy); sCtx.lineTo(cx + r + 35, cy - 10); sCtx.lineTo(cx + r + 35, cy + 10);
            sCtx.closePath(); sCtx.fill();
            if (pointerIndex !== null) {
                sCtx.fillStyle = '#03dac6';
                sCtx.font = 'bold 14px sans-serif';
                sCtx.fillText(`Case: ${rouletteSlices[pointerIndex].label}`, 225, 120);
            }
        }

        function spinSlotMachine() {
            if (gameState.slotTokens <= 0) return document.getElementById('slot-result').innerText = 'Plus de jetons üò¢';
            gameState.slotTokens -= 1;
            const result = weightedRoulettePick();
            const idx = rouletteSlices.indexOf(result);
            const sliceAngle = (Math.PI * 2) / rouletteSlices.length;
            const targetAngle = (Math.PI * 8) + ((rouletteSlices.length - idx) * sliceAngle);
            const startAngle = rouletteAngle;
            const startTime = performance.now();
            const duration = 1700;

            function animate(now) {
                const t = Math.min((now - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);
                rouletteAngle = startAngle + (targetAngle - startAngle) * eased;
                drawRoulette();
                if (t < 1) return requestAnimationFrame(animate);
                gameState.slotTokens += result.gain;
                document.getElementById('slot-result').innerText = result.gain > 0 ? `R√©sultat ${result.label}: +${result.gain} jetons` : 'Perdu, maison gagnante.';
                document.getElementById('slot-tokens').innerText = gameState.slotTokens;
                drawRoulette(idx);
            }
            requestAnimationFrame(animate);
        }

        const bCanv = document.getElementById('blackjack-canvas');
        const bCtx = bCanv.getContext('2d');
        let bjPlayer = [], bjDealer = [], bjDeck = [], bjDone = true;

        function newDeck() {
            const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            bjDeck = [];
            for (let suit = 0; suit < 4; suit++) vals.forEach(v => bjDeck.push(v));
            bjDeck.sort(() => Math.random() - 0.5);
        }

        function handValue(hand) {
            let total = 0, aces = 0;
            hand.forEach(v => { if (v === 'A') { total += 11; aces++; } else if (['J','Q','K'].includes(v)) total += 10; else total += Number(v); });
            while (total > 21 && aces-- > 0) total -= 10;
            return total;
        }

        function drawBlackjack(revealDealer = false) {
            bCtx.fillStyle = '#052e16'; bCtx.fillRect(0,0,bCanv.width,bCanv.height);
            bCtx.fillStyle = '#fff'; bCtx.font = '13px sans-serif';
            bCtx.fillText(`Dealer: ${revealDealer ? handValue(bjDealer) : '?'}`, 10, 18);
            bCtx.fillText(`Player: ${handValue(bjPlayer)}`, 10, 128);
            bjDealer.forEach((c, i) => drawCard(20 + i * 45, 28, revealDealer || i === 0 ? c : 'üÇ†'));
            bjPlayer.forEach((c, i) => drawCard(20 + i * 45, 140, c));
        }

        function drawCard(x, y, label) {
            bCtx.fillStyle = '#f8fafc'; bCtx.fillRect(x, y, 38, 56);
            bCtx.strokeStyle = '#111'; bCtx.strokeRect(x, y, 38, 56);
            bCtx.fillStyle = '#111'; bCtx.font = '14px sans-serif'; bCtx.fillText(label, x + 10, y + 32);
        }

        function startBlackjackRound() {
            if (gameState.slotTokens < 2) return document.getElementById('blackjack-result').innerText = 'Pas assez de jetons (2 requis).';
            gameState.slotTokens -= 2;
            newDeck();
            bjPlayer = [bjDeck.pop(), bjDeck.pop()];
            bjDealer = [bjDeck.pop(), bjDeck.pop()];
            bjDone = false;
            document.getElementById('slot-tokens').innerText = gameState.slotTokens;
            document.getElementById('blackjack-result').innerText = 'Main en cours...';
            animateBlackjackReveal(0);
        }

        function animateBlackjackReveal(step) {
            drawBlackjack(false);
            if (step > 2) return;
            setTimeout(() => animateBlackjackReveal(step + 1), 120);
        }

        function blackjackHit() {
            if (bjDone) return;
            bjPlayer.push(bjDeck.pop());
            drawBlackjack(false);
            if (handValue(bjPlayer) > 21) finishBlackjack();
        }

        function blackjackStand() {
            if (bjDone) return;
            while (handValue(bjDealer) < 17) bjDealer.push(bjDeck.pop());
            finishBlackjack();
        }

        function finishBlackjack() {
            bjDone = true;
            const p = handValue(bjPlayer), d = handValue(bjDealer);
            let msg = '√âgalit√©.';
            if (p > 21) msg = 'Bust, perdu.';
            else if (d > 21 || p > d) { gameState.slotTokens += 5; msg = 'Gagn√© ! +5 jetons'; }
            else if (p < d) msg = 'Perdu.';
            else { gameState.slotTokens += 2; msg = 'Push, mise rembours√©e (+2).'; }
            document.getElementById('slot-tokens').innerText = gameState.slotTokens;
            document.getElementById('blackjack-result').innerText = msg;
            drawBlackjack(true);
        }

        drawRoulette();
        drawBlackjack(false);

        // ==========================================
        // MINIGAME 3: SWARM SURVIVAL (Brutal Mode)
        // ==========================================
        const dCanv = document.getElementById('dodge-canvas');
        const dCtx = dCanv.getContext('2d');
        let player = { x: 300, y: 200, size: 15 }, enemies = [], dTime = 0, lastTick = Date.now();

        dCanv.addEventListener('mousemove', e => {
            const rect = dCanv.getBoundingClientRect();
            player.x = e.clientX - rect.left; player.y = e.clientY - rect.top;
        });

        function resetMinigameProgress() {
            gameState.unlockedMemory = false;
            gameState.unlockedFlappy = false;
            gameState.unlockedFinal = false;
            gameState.memorySolved = false;
            gameState.memoryAttempts = 0;
            gameState.tetrisHigh = 0;
            gameState.flappyHigh = 0;
            document.getElementById('tetris-score').innerText = "0";
            document.getElementById('flappy-score').innerText = "0";
            initMemoryGame();
            checkUnlocks();
            saveGame();
            
            // Boot player back to Tetris tab
            switchTab('screen-tetris', document.getElementById('btn-tetris'));
        }

        function dodgeLoop() {
            if (currentActiveTab === 'screen-final') {
                const now = Date.now(); const dt = now - lastTick; lastTick = now;
                dTime += dt;
                document.getElementById('dodge-score').innerText = (dTime / 1000).toFixed(1);

                // Make it harder: Spawn rate increases dramatically as time goes on
                let spawnRate = 0.1 + (dTime / 30000) * 0.5;

                if(Math.random() < spawnRate) { 
                    let side = Math.floor(Math.random()*4);
                    let x = side%2===0 ? Math.random()*600 : (side===1?600:0);
                    let y = side%2!==0 ? Math.random()*400 : (side===0?0:400);
                    let angle = Math.atan2(player.y - y, player.x - x);
                    // Enemies also get slightly faster over time
                    let speed = 3 + (dTime / 30000) * 3;
                    enemies.push({ x: x, y: y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, size: 8 });
                }

                dCtx.fillStyle = 'rgba(0,0,0,0.3)'; dCtx.fillRect(0,0,600,400); 
                dCtx.fillStyle = '#bb86fc'; dCtx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);

                for (let i = enemies.length-1; i >= 0; i--) {
                    let e = enemies[i];
                    e.x += e.vx; e.y += e.vy;
                    dCtx.fillStyle = '#cf6679'; dCtx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
                    
                    // Hit detection - THE PUNISHMENT
                    let dist = Math.hypot(player.x - e.x, player.y - e.y);
                    if (dist < (player.size/2 + e.size/2)) {
                        dTime = 0; enemies = []; 
                        alert("YOU DIED!\nThe Swarm consumed you. Your minigame progress has been wiped. Back to Tetris you go!");
                        resetMinigameProgress();
                        return; // Exit out of the loop iteration to prevent bugs
                    }
                    if (e.x < -50 || e.x > 650 || e.y < -50 || e.y > 450) enemies.splice(i, 1);
                }

                if (dTime >= 30000) {
                    alert("YOU DID IT! You survived the swarm and beat the game!");
                    dTime = 0; enemies = [];
                }
            } else { lastTick = Date.now(); } 
            requestAnimationFrame(dodgeLoop);
        }

        function varColor(name) { return getComputedStyle(document.body).getPropertyValue(name); }
    </script>
</body>
</html>
