<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Empire - Connected Edition</title>
    <style>
        /* --- CSS VARIABLES & RESET --- */
        :root {
            --bg: #121212; --panel: #1e1e1e; --accent: #bb86fc;
            --gold: #ffd700; --red: #cf6679; --green: #03dac6;
            --text: #ffffff; --text-sec: #b0b0b0;
            --panel-soft: #25293a;
            --border-soft: rgba(187, 134, 252, 0.28);
        }

        body {
            margin: 0; padding: 0; font-family: 'Roboto', 'Segoe UI', sans-serif;
            background: radial-gradient(circle at top, #1f263c 0%, #121212 45%);
            color: var(--text);
            height: 100vh; overflow: hidden; user-select: none; display: flex; flex-direction: column;
        }

        /* --- TABS NAVIGATION --- */
        #tabs-bar {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0, 0, 0, 0.45); backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-soft); gap: 10px; z-index: 5;
        }
        .tabs-group { display: flex; flex-wrap: wrap; gap: 10px; }
        .tab-btn {
            background: #222837; color: var(--text-sec); border: 1px solid #444c61;
            padding: 10px 20px; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: 0.3s;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); box-shadow: 0 0 16px rgba(187, 134, 252, 0.45); }
        .tab-btn:hover:not(.active) { background: #31364b; color: white; }
        .tab-btn.logout { background: transparent; color: #ff8f9f; border-color: rgba(255, 143, 159, 0.6); }
        .tab-btn.logout:hover { background: rgba(255, 143, 159, 0.15); }
        .hidden { display: none !important; }

        /* --- SCREENS --- */
        .screen { display: none; width: 100%; height: 100%; flex: 1; }
        .screen.active { display: flex; }

        /* --- CLICKER LAYOUT --- */
        #game-layer { display: flex; width: 100%; height: 100%; transition: filter 0.5s ease; }
        .blurred { filter: blur(20px); pointer-events: none; }
        .game-area { flex: 6; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, #2f3855 0%, #121212 78%); position: relative; }
        .shop-area { flex: 4; background: linear-gradient(170deg, #1e1e2c 0%, #151723 100%); display: flex; flex-direction: column; border-left: 1px solid var(--border-soft); max-width: 450px; }

        /* --- GAME ELEMENTS --- */
        .header-stats { text-align: center; margin-bottom: 20px; z-index: 2; }
        #score { font-size: 4rem; font-weight: 800; color: var(--text); text-shadow: 0 0 20px rgba(187, 134, 252, 0.3); }
        #cps { color: var(--text-sec); font-size: 1.2rem; }
        .prestige-badge { background: linear-gradient(45deg, #FFD700, #FFA500); color: black; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 0.9rem; margin-top: 10px; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); display: inline-block; }
        #cookie { font-size: 200px; cursor: pointer; transition: transform 0.05s; filter: drop-shadow(0 0 30px rgba(0,0,0,0.5)); z-index: 2; }
        #cookie:active { transform: scale(0.95); }
        .goal-text { color: var(--red); font-weight: bold; margin-top: 20px; font-size: 1.1rem; }

        /* --- SHOP & ADMIN --- */
        .shop-header { padding: 20px; background: var(--panel-soft); border-bottom: 1px solid var(--border-soft); display: flex; justify-content: space-between; align-items: center; }
        .shop-content { flex: 1; overflow-y: auto; padding: 10px; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .shop-item { background: #2a3042; margin-bottom: 8px; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; transition: all 0.2s; }
        .shop-item:hover { transform: translateX(-4px); background: #333b52; border-color: var(--border-soft); }
        .item-info h4 { margin: 0; font-size: 1rem; color: var(--text); }
        .item-info p { margin: 4px 0 0; font-size: 0.75rem; color: var(--text-sec); }
        .item-cost { font-weight: bold; color: var(--gold); }
        .buy-btn { background: #202735; border: 1px solid #555; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; min-width: 80px; transition: 0.2s; }
        .can-buy { background: var(--green); color: black; border-color: var(--green); font-weight: bold; }
        .locked { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        #ascend-btn { width: 100%; padding: 20px; background: linear-gradient(45deg, #e94560, #c0392b); color: white; border: none; font-weight: bold; font-size: 1.2rem; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; display: none; }
        #ascend-btn:hover { filter: brightness(1.2); }
        .floater { position: absolute; font-size: 24px; font-weight: bold; color: white; pointer-events: none; animation: floatUp 1s ease-out forwards; }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
        .admin-panel { border-top: 1px solid var(--border-soft); padding: 12px; background: #1b2030; }
        .admin-panel h4 { margin: 0 0 8px; color: var(--gold); }
        .admin-panel input {
            width: 100%; padding: 9px; margin: 6px 0; border-radius: 6px;
            background: #111623; border: 1px solid #3c4560; color: #fff;
        }
        #admin-status { min-height: 20px; color: var(--text-sec); font-size: 0.85rem; margin-top: 6px; }

        /* --- MINIGAME CANVASES --- */
        .canvas-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #111; }
        canvas { border: 2px solid var(--accent); background: #000; box-shadow: 0 0 20px rgba(187,134,252,0.2); }
        .minigame-ui { text-align: center; margin-bottom: 15px; }
        .minigame-ui h2 { margin: 0; color: var(--accent); }
        .minigame-ui p { margin: 5px 0 0 0; color: var(--text-sec); }
        .warning-text { color: var(--red); font-weight: bold; font-size: 1.2rem; text-transform: uppercase; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }


        .relax-grid { display: grid; grid-template-columns: repeat(2, minmax(340px, 1fr)); gap: 18px; width: min(95vw, 900px); }
        .relax-card { background: #171c2a; border: 1px solid var(--border-soft); border-radius: 10px; padding: 12px; }
        .relax-card h3 { margin: 0 0 8px; color: var(--green); }
        .actions-row { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
        .memory-board {
            display:grid; grid-template-columns: repeat(10, 52px); gap:8px; justify-content:center;
            margin-top: 10px; max-height: 360px; overflow-y: auto; padding: 8px; background: #0d111d; border-radius: 10px; border: 1px solid #2f3855;
        }
        .memory-card { width:52px; height:52px; border-radius:8px; border:1px solid #495170; background:#26304a; color:#fff; font-size:24px; cursor:pointer; transition: transform .2s, background .2s; }
        .memory-card:hover { transform: translateY(-2px); }
        .memory-card.revealed, .memory-card.matched { background:#03dac6; color:#111; }
        .memory-card.matched { cursor:default; opacity:.85; }


        .ad-banner { background: linear-gradient(90deg, #ff4d6d, #ff8fa3); color:#1a0d12; font-weight:700; padding:8px 14px; text-align:center; border-bottom:1px solid rgba(0,0,0,.2); }
        .ad-banner span { color:#2b0010; text-shadow: 0 1px 0 rgba(255,255,255,.4); }
        .death-popup { position: fixed; inset: 0; background: rgba(0,0,0,.75); display:none; align-items:center; justify-content:center; z-index:30; }
        .death-popup .box { width:min(90vw,560px); background:#161b2b; border:1px solid var(--border-soft); border-radius:12px; padding:16px; text-align:center; }
        .death-popup img { max-width:100%; max-height:260px; border-radius:10px; border:1px solid #3d465f; }

        /* --- LOGIN MODAL --- */
        #login-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: rgba(6,8,14,0.8); z-index: 10; }
        .card { background: linear-gradient(170deg, #202434 0%, #161a28 100%); padding: 40px; border-radius: 14px; text-align: center; border: 1px solid var(--border-soft); width: 320px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35); }
        input { width: 90%; padding: 10px; margin: 10px 0; background: #121726; border: 1px solid #39415a; color: white; border-radius: 5px; }
        .btn-main { width: 100%; padding: 12px; background: var(--accent); color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="login-modal">
        <div class="card">
            <h2 style="color: var(--accent)">Swarm Login</h2>
            <p id="login-status" style="color: var(--text-sec); font-size: 0.9rem; margin-bottom: 10px;">Checking connection...</p>
            <input type="text" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <button class="btn-main" onclick="manualLogin()">ENTER SYSTEM</button>
        </div>
    </div>

    <div id="tabs-bar" class="hidden">
        <div class="tabs-group">
            <button id="btn-clicker" class="tab-btn active" onclick="switchTab('screen-clicker', this)">Main Terminal</button>
            <button id="btn-tetris" class="tab-btn hidden" onclick="switchTab('screen-tetris', this)">Tetris (Score: <span id="tetris-high">0</span>/1000)</button>
            <button id="btn-memory" class="tab-btn hidden" onclick="switchTab('screen-memory', this)">Memory 50 cartes</button>
            <button id="btn-flappy" class="tab-btn hidden" onclick="switchTab('screen-flappy', this)">Flappy (Score: <span id="flappy-high">0</span>/20)</button>
            <button id="btn-final" class="tab-btn hidden" onclick="switchTab('screen-final', this)">Swarm Survival</button>
            <button id="btn-relax" class="tab-btn" onclick="switchTab('screen-relax', this)">Espace d√©tente</button>
            <button id="btn-poker" class="tab-btn hidden" onclick="switchTab('screen-poker', this)">Poker Ultimate</button>
        </div>
        <button class="tab-btn logout" onclick="logout()">Se d√©connecter</button>
    </div>

    <div id="ad-banner" class="ad-banner hidden"><span id="ad-banner-text">üî• De beaux hommes te recherchent proche de chez toi ‚Äî soir√©e r√©tro, musique lente, sc√©nario torride niveau 2010.</span></div>

    <div id="screen-clicker" class="screen active">
        <div id="game-layer" class="blurred">
            <div class="game-area">
                <div class="header-stats">
                    <div id="score">0</div>
                    <div id="cps">0 Cookies / Sec</div>
                    <div id="prestige-display" class="prestige-badge hidden">
                        MULTIPLIER: x<span id="mult-val">1</span>
                    </div>
                    <div id="tetris-goal" class="goal-text">Goal: Reach 1,000,000,000 Qa Cookies to unlock the Arcade!</div>
                </div>
                <div id="cookie" onclick="clickCookie(event)">üç™</div>
            </div>

            <div class="shop-area">
                <div class="shop-header">
                    <h3>MARKETPLACE</h3>
                    <small id="wallet">0</small>
                </div>
                <div class="shop-content" id="shop-list"></div>
                <div id="admin-panel" class="admin-panel hidden">
                    <h4>ADMIN - Create account</h4>
                    <input id="admin-email" placeholder="email">
                    <input id="admin-password" type="password" placeholder="password (min 8)">
                    <input id="admin-firstname" placeholder="first name (optional)">
                    <input id="admin-lastname" placeholder="last name (optional)">
                    <button class="buy-btn can-buy" style="width:100%;margin-top:6px" onclick="adminCreateUser()">Create user</button>
                    <div id="admin-status"></div>
                </div>
                <button id="ascend-btn" onclick="ascend()">
                    ‚ö†Ô∏è SYSTEM REBOOT ‚ö†Ô∏è<br>
                    <span style="font-size: 0.7rem; opacity: 0.8">Reset Cookies for x2 Income</span>
                </button>
            </div>
        </div>
    </div>

    <div id="screen-tetris" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>TETRIS</h2>
                <p>Arrow keys to move/rotate. Down to drop. Reach 1000 to unlock next module.</p>
                <h3 style="color:var(--gold)">Score: <span id="tetris-score">0</span></h3>
            </div>
            <canvas id="tetris-canvas" width="240" height="400"></canvas>
        </div>
    </div>


    <div id="screen-memory" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>MEMORY - 50 CARTES</h2>
                <p>Trouve les 25 paires d'√©mojis pour d√©verrouiller Flappy Bird.</p>
                <h3 style="color:var(--gold)">Paires: <span id="memory-matched">0</span>/25</h3>
                <h3>Essais: <span id="memory-attempts">0</span></h3>
            </div>
            <div id="memory-board" class="memory-board"></div>
        </div>
    </div>

    <div id="screen-flappy" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>FLAPPY BIRD</h2>
                <p>Click or Spacebar to jump. Reach 20 to unlock the final challenge.</p>
                <h3 style="color:var(--gold)">Score: <span id="flappy-score">0</span></h3>
            </div>
            <canvas id="flappy-canvas" width="320" height="480"></canvas>
        </div>
    </div>

    <div id="screen-relax" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>ESPACE D√âTENTE üé∞üÉè</h2>
                <p>Machine √† sous + Roulette + Blackjack. Mise libre partout.</p>
                <h3 style="color:var(--gold)">Jetons: <span id="slot-tokens">50</span></h3>
                <p id="poker-unlock-hint">Atteins 1000 jetons pour d√©bloquer Poker Ultimate.</p>
            </div>
            <div class="relax-grid">
                <div class="relax-card">
                    <h3>Machine √† sous</h3>
                    <p id="slot-result">Pr√™t √† lancer</p>
                    <canvas id="slot-canvas" width="360" height="220"></canvas>
                    <div class="actions-row">
                        <input id="slot-bet" type="number" min="1" value="5" style="width:100px" />
                        <button class="buy-btn can-buy" onclick="spinSlotMachine()">Lancer</button>
                    </div>
                </div>
                <div class="relax-card">
                    <h3>Roulette (Rouge/Noir/Pair/Impair)</h3>
                    <p id="roulette-result">Choisis une mise puis lance.</p>
                    <canvas id="roulette-canvas" width="360" height="220"></canvas>
                    <div class="actions-row" style="margin-bottom:8px; flex-wrap: wrap;">
                        <button class="buy-btn" onclick="setRouletteBetType('red')">Rouge</button>
                        <button class="buy-btn" onclick="setRouletteBetType('black')">Noir</button>
                        <button class="buy-btn" onclick="setRouletteBetType('even')">Pair</button>
                        <button class="buy-btn" onclick="setRouletteBetType('odd')">Impair</button>
                    </div>
                    <div class="actions-row">
                        <input id="roulette-bet" type="number" min="1" value="5" style="width:100px" />
                        <button class="buy-btn can-buy" onclick="spinRoulette()">Miser</button>
                    </div>
                </div>
                <div class="relax-card">
                    <h3>Blackjack</h3>
                    <p id="blackjack-result">Lance une partie.</p>
                    <canvas id="blackjack-canvas" width="360" height="220"></canvas>
                    <div class="actions-row">
                        <input id="blackjack-bet" type="number" min="1" value="10" style="width:100px" />
                        <button class="buy-btn" onclick="startBlackjackRound()">Nouvelle main</button>
                        <button class="buy-btn" onclick="blackjackHit()">Hit</button>
                        <button class="buy-btn" onclick="blackjackStand()">Stand</button>
                    </div>
                </div>
                <div class="relax-card">
                    <h3>Poker classique</h3>
                    <p id="classic-poker-result">Joue une main 5 cartes contre la banque.</p>
                    <div class="actions-row">
                        <input id="classic-poker-bet" type="number" min="1" value="15" style="width:100px" />
                        <button class="buy-btn" onclick="playClassicPoker()">Jouer</button>
                    </div>
                </div>
                <div class="relax-card">
                    <h3>Don de jetons</h3>
                    <p id="gift-result">Choisis un joueur et envoie des jetons.</p>
                    <small id="gift-count" style="color:var(--text-sec)"></small>
                    <div class="actions-row">
                        <select id="gift-user" style="max-width:220px"></select>
                        <input id="gift-amount" type="number" min="1" value="20" style="width:100px" />
                        <button class="buy-btn" onclick="sendTokenGift()">Envoyer</button>
                        <button class="buy-btn" onclick="loadAvailableUsers()">Rafra√Æchir liste</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-poker" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>POKER ULTIMATE ‚ô†Ô∏è</h2>
                <p>Jeu secret d√©bloqu√© √† 1000 jetons. 1 carte contre la banque: plus haute carte gagne (A haut).</p>
                <h3 style="color:var(--gold)">Jetons: <span id="poker-tokens">50</span></h3>
            </div>
            <div class="relax-card" style="width:min(95vw, 640px)">
                <h3>Duel rapide</h3>
                <p id="poker-result">Place une mise pour jouer.</p>
                <div class="actions-row">
                    <input id="poker-bet" type="number" min="1" value="25" style="width:100px" />
                    <button class="buy-btn can-buy" onclick="playPokerUltimate()">Jouer</button>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-final" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>SWARM SURVIVAL</h2>
                <p class="warning-text">‚ö†Ô∏è DODGE THE SWARM ‚ö†Ô∏è</p>
                <p>Move your mouse to control the blue square. DODGE the red swarm. Survive 30 seconds.</p>
                <h3 style="color:var(--gold)">Time: <span id="dodge-score">0</span>s / 30s</h3>
            </div>
            <canvas id="dodge-canvas" width="600" height="400"></canvas>
            <div class="actions-row"><button class="buy-btn" onclick="restartSwarmRun()">Relancer</button></div>
        </div>
    </div>

    <div id="death-popup" class="death-popup">
        <div class="box">
            <h3 id="death-title">GAME OVER</h3>
            <img id="death-image" alt="retro death" src=""/>
            <p id="death-text"></p>
            <button class="buy-btn can-buy" onclick="closeDeathPopup()">Rejouer</button>
        </div>
    </div>

    <script src="/config.js"></script>
    <script>
        const BASE_URL = (window.__APP_CONFIG__ && window.__APP_CONFIG__.API_BASE_URL) || "http://192.168.100.91:3000"; 
        let currentUser = null;
        let saveLoopStarted = false;

        const buildingDefs = [
            { id: 'cursor',  name: 'Better Mouse',   baseCost: 15,      val: 1,      type: 'click' },
            { id: 'grandma', name: 'Grandma',        baseCost: 100,     val: 5,      type: 'auto' },
            { id: 'farm',    name: 'Cookie Farm',    baseCost: 1100,    val: 15,     type: 'auto' },
            { id: 'mine',    name: 'Cookie Mine',    baseCost: 12000,   val: 50,     type: 'auto' },
            { id: 'factory', name: 'Factory',        baseCost: 130000,  val: 150,    type: 'auto' },
            { id: 'bank',    name: 'Bank',           baseCost: 1400000, val: 500,    type: 'auto' },
            { id: 'temple',  name: 'Temple',         baseCost: 20000000,val: 1500,   type: 'auto' },
            { id: 'wiz',     name: 'Wizard Tower',   baseCost: 330000000, val: 5000, type: 'auto' },
            { id: 'ship',    name: 'Shipment',       baseCost: 5100000000, val: 20000, type: 'auto' },
            { id: 'alchemy', name: 'Alchemy Lab',    baseCost: 75000000000, val: 100000, type: 'auto' },
            { id: 'portal',  name: 'Portal',         baseCost: 1000000000000, val: 500000, type: 'auto' },
            { id: 'time',    name: 'Time Machine',   baseCost: 14000000000000, val: 2000000, type: 'auto' }
        ];

        let gameState = {
            cookies: 0, clickBase: 1, autoBase: 0, multiplier: 1, buildings: {},
            unlockedTetris: false, unlockedMemory: false, unlockedFlappy: false, unlockedFinal: false,
            memorySolved: false, memoryAttempts: 0,
            tetrisHigh: 0, flappyHigh: 0, slotTokens: 50, unlockedPoker: false, rewardFlags: {}, flappyRewardMilestones: [], usersCache: []
        };

        buildingDefs.forEach(b => gameState.buildings[b.id] = 0);

        // --- AUTH & NETWORK ---
        window.onload = async function() {
            try {
                const response = await fetch(`${BASE_URL}/api/auth/me`, { method: "GET", credentials: "include" });
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('login-status').innerText = "Session found! Loading...";
                    await startGame(data);
                } else { document.getElementById('login-status').innerText = "Please log in."; }
            } catch (error) { document.getElementById('login-status').innerText = "Cannot connect to server."; }
        };

        async function manualLogin() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const statusText = document.getElementById('login-status');
            if (!email || !pass) return statusText.innerText = "Please enter email and password.";
            statusText.innerText = "Authenticating...";

            try {
                const response = await fetch(`${BASE_URL}/api/auth/login`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ email: email.trim(), password: pass })
                });
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.error || "Invalid credentials");
                }
                await startGame(await response.json());
            } catch (error) { statusText.innerText = `Login Failed: ${error.message || "UNKNOWN"}`; }
        }

        async function logout() {
            try {
                await fetch(`${BASE_URL}/api/auth/logout`, { method: 'POST', credentials: 'include' });
            } catch (error) {
                console.warn('Logout request failed, clearing local session only.');
            }

            currentUser = null;
            document.getElementById('login-modal').classList.remove('hidden');
            document.getElementById('game-layer').classList.add('blurred');
            document.getElementById('tabs-bar').classList.add('hidden');
            document.getElementById('ad-banner').classList.add('hidden');
            document.getElementById('admin-panel').classList.add('hidden');
            document.getElementById('login-status').innerText = "Session closed. Please log in.";
        }

        async function startGame(data) {
            currentUser = data?.user || null;
            await loadGameState();
            
            document.getElementById('login-modal').classList.add('hidden');
            document.getElementById('game-layer').classList.remove('blurred');
            document.getElementById('tabs-bar').classList.remove('hidden');
            document.getElementById('admin-panel').classList.toggle('hidden', currentUser?.role !== "ADMIN");
            
            if (gameState.multiplier > 1) {
                document.getElementById('prestige-display').classList.remove('hidden');
                document.getElementById('mult-val').innerText = gameState.multiplier;
            }

            checkUnlocks();
            renderShop();
            document.getElementById('ad-banner').classList.remove('hidden');
            if (!window.__adRotationStarted) { startAdBannerRotation(); window.__adRotationStarted = true; }
            loadAvailableUsers();
            updateUI();
            
            if (!saveLoopStarted) {
                setInterval(autoLoop, 1000);
                setInterval(saveGame, 10000); 
                saveLoopStarted = true;
                
                requestAnimationFrame(tetrisLoop);
                requestAnimationFrame(flappyLoop);
                requestAnimationFrame(dodgeLoop);
            }
            initMemoryGame();
        }

        async function loadGameState() {
            try {
                const response = await fetch(`${BASE_URL}/api/game/state`, { method: "GET", credentials: "include" });
                if (!response.ok) return;
                const data = await response.json();
                if (!data?.gameState) return;
                
                gameState.cookies = Number(data.gameState.cookies ?? 0);
                gameState.clickBase = Number(data.gameState.clickBase ?? 1);
                gameState.autoBase = Number(data.gameState.autoBase ?? 0);
                gameState.multiplier = Number(data.gameState.multiplier ?? 1);
                gameState.buildings = data.gameState.buildings || {};
                
                gameState.unlockedTetris = data.gameState.unlockedTetris || false;
                gameState.unlockedMemory = data.gameState.unlockedMemory || false;
                gameState.unlockedFlappy = data.gameState.unlockedFlappy || false;
                gameState.unlockedFinal = data.gameState.unlockedFinal || false;
                gameState.memorySolved = data.gameState.memorySolved || false;
                gameState.memoryAttempts = Number(data.gameState.memoryAttempts ?? 0);
                gameState.tetrisHigh = data.gameState.tetrisHigh || 0;
                gameState.flappyHigh = data.gameState.flappyHigh || 0;
                gameState.slotTokens = Number(data.gameState.slotTokens ?? 50);
                gameState.unlockedPoker = Boolean(data.gameState.unlockedPoker ?? false);
                gameState.rewardFlags = data.gameState.rewardFlags || {};
                gameState.flappyRewardMilestones = data.gameState.flappyRewardMilestones || [];
                gameState.usersCache = data.gameState.usersCache || [];

                buildingDefs.forEach(b => { if (typeof gameState.buildings[b.id] !== "number") gameState.buildings[b.id] = 0; });
            } catch (error) { console.error("Failed to load game state"); }
        }

        async function saveGame() {
            if (!currentUser) return;
            try {
                await fetch(`${BASE_URL}/api/game/save`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ state: gameState })
                });
            } catch (error) {}
        }

        async function adminCreateUser() {
            if (!currentUser || currentUser.role !== "ADMIN") return;
            const status = document.getElementById("admin-status");
            const email = document.getElementById("admin-email").value.trim();
            const password = document.getElementById("admin-password").value;
            const firstName = document.getElementById("admin-firstname").value.trim();
            const lastName = document.getElementById("admin-lastname").value.trim();

            status.innerText = "Creating...";
            try {
                const response = await fetch(`${BASE_URL}/api/admin/users`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify({
                        email,
                        password,
                        ...(firstName ? { firstName } : {}),
                        ...(lastName ? { lastName } : {})
                    })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data.error || "CREATE_FAILED");
                }
                status.style.color = "var(--green)";
                status.innerText = `Created: ${data.user.email}`;
                document.getElementById("admin-email").value = "";
                document.getElementById("admin-password").value = "";
                document.getElementById("admin-firstname").value = "";
                document.getElementById("admin-lastname").value = "";
            } catch (error) {
                status.style.color = "var(--red)";
                status.innerText = `Failed: ${error.message || "UNKNOWN"}`;
            }
        }

        // --- TAB LOGIC ---
        let currentActiveTab = 'screen-clicker';
        function switchTab(screenId, btnElement) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            btnElement.classList.add('active');
            currentActiveTab = screenId;
            if (screenId === 'screen-memory') renderMemoryBoard();
        }

        function checkUnlocks() {
            // 1e24 = 1 Septillion = 1,000,000,000 Quadrillion (Qa)
            if (gameState.cookies >= 1e24) {
                gameState.unlockedTetris = true;
                document.getElementById('tetris-goal').classList.add('hidden');
            } else if (!gameState.unlockedTetris) {
                document.getElementById('tetris-goal').classList.remove('hidden');
            }

            if (gameState.tetrisHigh >= 1000) gameState.unlockedMemory = true;
            if (gameState.memorySolved) gameState.unlockedFlappy = true;
            if (gameState.flappyHigh >= 20) gameState.unlockedFinal = true;

            if (gameState.unlockedTetris) document.getElementById('btn-tetris').classList.remove('hidden');
            else document.getElementById('btn-tetris').classList.add('hidden');
            
            if (gameState.unlockedMemory) document.getElementById('btn-memory').classList.remove('hidden');
            else document.getElementById('btn-memory').classList.add('hidden');

            if (gameState.unlockedFlappy) document.getElementById('btn-flappy').classList.remove('hidden');
            else document.getElementById('btn-flappy').classList.add('hidden');
            
            if (gameState.unlockedFinal) document.getElementById('btn-final').classList.remove('hidden');
            else document.getElementById('btn-final').classList.add('hidden');

            if (gameState.slotTokens >= 1000) gameState.unlockedPoker = true;
            document.getElementById('btn-poker').classList.toggle('hidden', !gameState.unlockedPoker);
            document.getElementById('poker-unlock-hint').innerText = gameState.unlockedPoker ? 'Poker Ultimate d√©bloqu√© ‚úÖ' : 'Atteins 1000 jetons pour d√©bloquer Poker Ultimate.';
            document.getElementById('tetris-high').innerText = gameState.tetrisHigh;
            document.getElementById('flappy-high').innerText = gameState.flappyHigh;
            document.getElementById('slot-tokens').innerText = gameState.slotTokens;
            document.getElementById('poker-tokens').innerText = gameState.slotTokens;
        }

        // --- CORE CLICKER ---
        function clickCookie(e) {
            let amount = gameState.clickBase * gameState.multiplier;
            gameState.cookies += amount;
            spawnFloater(e.clientX, e.clientY, "+" + formatNumber(amount));
            updateUI();
        }

        function autoLoop() {
            if (gameState.autoBase > 0) {
                gameState.cookies += (gameState.autoBase * gameState.multiplier);
                updateUI();
            }
        }

        function ascend() {
            if (gameState.cookies < 10000) return;
            if(!confirm("REBOOT SYSTEM? \n\nYou lose cookies & buildings. Gain permanent x2 Income.")) return;
            gameState.multiplier *= 2; gameState.cookies = 0; gameState.clickBase = 1; gameState.autoBase = 0;
            buildingDefs.forEach(b => gameState.buildings[b.id] = 0);
            document.getElementById('prestige-display').classList.remove('hidden');
            document.getElementById('mult-val').innerText = gameState.multiplier;
            document.getElementById('ascend-btn').style.display = 'none';
            renderShop(); updateUI(); saveGame(); 
        }

        function buy(id) {
            const item = buildingDefs.find(b => b.id === id);
            const cost = getCost(item);
            if (gameState.cookies >= cost) {
                gameState.cookies -= cost; gameState.buildings[id]++;
                if (item.type === 'click') gameState.clickBase += item.val;
                if (item.type === 'auto')  gameState.autoBase += item.val;
                updateUI(); renderShop(); 
            }
        }

        function getCost(item) { return Math.floor(item.baseCost * Math.pow(1.15, gameState.buildings[item.id])); }

        function renderShop() {
            const list = document.getElementById('shop-list');
            list.innerHTML = ""; 
            buildingDefs.forEach(item => {
                const cost = getCost(item); const count = gameState.buildings[item.id];
                const canAfford = gameState.cookies >= cost;
                list.innerHTML += `
                    <div class="shop-item">
                        <div class="item-info">
                            <h4>${item.name} <span style="color:#666; font-size:0.8em">x${count}</span></h4>
                            <p>+${formatNumber(item.val * gameState.multiplier)} ${item.type === 'click' ? 'Click' : '/ sec'}</p>
                            <div class="item-cost">üç™ ${formatNumber(cost)}</div>
                        </div>
                        <button class="buy-btn ${canAfford ? 'can-buy' : 'locked'}" onclick="buy('${item.id}')">BUY</button>
                    </div>
                `;
            });
        }

        function updateUI() {
            document.getElementById('score').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('wallet').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('cps').innerText = formatNumber(gameState.autoBase * gameState.multiplier) + " / Sec";
            document.getElementById('ascend-btn').style.display = gameState.cookies >= 10000 ? 'block' : 'none';

            const buttons = document.querySelectorAll('.buy-btn');
            buildingDefs.forEach((item, i) => {
                if(buttons[i]) buttons[i].className = `buy-btn ${gameState.cookies >= getCost(item) ? 'can-buy' : 'locked'}`;
            });
            checkUnlocks();
        }

        // --- UPDATED NUMBER FORMATTER ---
        function formatNumber(num) {
            if (num >= 1e27) return (num / 1e27).toFixed(2) + 'Oc'; // Octillion
            if (num >= 1e24) return (num / 1e24).toFixed(2) + 'Sp'; // Septillion (1,000,000,000 Qa)
            if (num >= 1e21) return (num / 1e21).toFixed(2) + 'Sx'; // Sextillion
            if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillion
            if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Qa'; // Quadrillion
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillion
            if (num >= 1e9)  return (num / 1e9).toFixed(2) + 'B';   // Billion
            if (num >= 1e6)  return (num / 1e6).toFixed(2) + 'M';   // Million
            if (num >= 1e3)  return (num / 1e3).toFixed(2) + 'k';   // Thousand
            return Math.floor(num).toString();
        }

        function spawnFloater(x, y, text) {
            const el = document.createElement('div');
            el.innerText = text; el.className = 'floater';
            el.style.left = (x - 20) + "px"; el.style.top = (y - 50) + "px";
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        const adMessages = [
            'üî• De beaux hommes te recherchent proche de chez toi ‚Äî sc√©nario torride r√©tro sous n√©ons violets.',
            'üíò Notification 2010: un inconnu √©l√©gant veut danser coll√©-serr√© jusqu\'√† minuit.',
            'üåô Message priv√©: rendez-vous interdit au lounge arcade, ambiance torride et synthwave.',
            '‚ú® Alerte locale: deux beaux gosses t\'attendent pour une nuit dramatique fa√ßon soap-op√©ra.'
        ];

        function startAdBannerRotation() {
            const target = document.getElementById('ad-banner-text');
            if (!target) return;
            let i = 0;
            target.innerText = adMessages[i];
            setInterval(() => {
                i = (i + 1) % adMessages.length;
                target.innerText = adMessages[i];
            }, 4500);
        }

        function retroImageDataUrl(gameName) {
            const palettes = [
                ['#2b1b47', '#e43f6f'], ['#102542', '#f87060'], ['#1f2041', '#4b3f72'], ['#0f3460', '#e94560']
            ];
            const pick = palettes[Math.floor(Math.random() * palettes.length)];
            const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='560' height='320'>
                <defs><linearGradient id='g' x1='0' x2='1' y1='0' y2='1'><stop offset='0%' stop-color='${pick[0]}'/><stop offset='100%' stop-color='${pick[1]}'/></linearGradient></defs>
                <rect width='560' height='320' fill='url(#g)'/>
                <text x='24' y='64' font-size='38' font-family='Verdana' fill='white'>GAME OVER</text>
                <text x='24' y='112' font-size='24' font-family='Verdana' fill='#ffeaa7'>${gameName}</text>
                <text x='24' y='286' font-size='18' font-family='Verdana' fill='white'>Arcade reboot mode ¬∑ 2010 vibes</text>
            </svg>`;
            return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        }

        function closeDeathPopup() { document.getElementById('death-popup').style.display = 'none'; }

        function showRetroDeathPopup(gameName, detail) {
            document.getElementById('death-title').innerText = `üíÄ ${gameName} - Tu es mort`;
            document.getElementById('death-text').innerText = detail || 'Respawn imm√©diat, ambiance arcade 2010.';
            document.getElementById('death-image').src = retroImageDataUrl(gameName);
            document.getElementById('death-popup').style.display = 'flex';
        }

        function claimOneTimeReward(flag, amount, message) {
            if (gameState.rewardFlags[flag]) return false;
            gameState.rewardFlags[flag] = true;
            gameState.slotTokens += amount;
            checkUnlocks();
            alert(`${message} +${amount} jetons`);
            return true;
        }

        function claimFlappyMilestone(score) {
            const marks = [30, 40, 50, 60, 70, 80, 100];
            if (!marks.includes(score)) return;
            if (gameState.flappyRewardMilestones.includes(score)) return;
            gameState.flappyRewardMilestones.push(score);
            const reward = score * 2;
            gameState.slotTokens += reward;
            checkUnlocks();
            alert(`Flappy milestone ${score} atteint: +${reward} jetons`);
        }

        async function loadAvailableUsers() {
            let users = [];
            try {
                const res = await fetch(`${BASE_URL}/api/users/list`, { method: 'GET', credentials: 'include' });
                if (res.ok) {
                    const data = await res.json();
                    users = (data.users || []).map(u => ({ id: u.id || u.email, name: u.email || u.username || u.id }));
                }
            } catch (error) {}
            if (!users.length) users = (gameState.usersCache.length ? gameState.usersCache : [
                { id: 'swarm.alex@hub', name: 'swarm.alex@hub' },
                { id: 'retro.lena@hub', name: 'retro.lena@hub' },
                { id: 'pixel.max@hub', name: 'pixel.max@hub' }
            ]);
            gameState.usersCache = users;
            const select = document.getElementById('gift-user');
            if (!select) return;
            select.innerHTML = '';
            const visibleUsers = users.filter(u => u.name !== currentUser?.email);
            visibleUsers.forEach(u => {
                const opt = document.createElement('option');
                opt.value = u.id; opt.textContent = u.name;
                select.appendChild(opt);
            });
            document.getElementById('gift-count').innerText = `${visibleUsers.length} utilisateur(s) disponible(s)`;
        }

        async function sendTokenGift() {
            const amount = Math.max(1, Math.floor(Number(document.getElementById('gift-amount').value) || 1));
            const userId = document.getElementById('gift-user').value;
            if (!userId) return document.getElementById('gift-result').innerText = 'Aucun joueur disponible.';
            if (gameState.slotTokens < amount) return document.getElementById('gift-result').innerText = 'Pas assez de jetons.';
            let sent = false;
            try {
                const res = await fetch(`${BASE_URL}/api/game/gift`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include',
                    body: JSON.stringify({ toUserId: userId, amount })
                });
                sent = res.ok;
            } catch (error) {}
            gameState.slotTokens -= amount;
            checkUnlocks();
            document.getElementById('gift-result').innerText = sent
                ? `Don envoy√©: ${amount} jetons.`
                : `Don simul√© localement: ${amount} jetons envoy√©s.`;
        }

        // ==========================================
        // MINIGAME 1: TETRIS
        // ==========================================
        const tCanv = document.getElementById('tetris-canvas');
        const tCtx = tCanv.getContext('2d');
        const COLS = 12, ROWS = 20, BLOCK = 20;
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let piece = null, tScore = 0, lastDrop = Date.now();
        const shapes = [ [],
            [[1,1,1,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]],
            [[1,1],[1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]]
        ];
        const colors = [null, '#00ffff', '#0000ff', '#ffa500', '#ffff00', '#00ff00', '#800080', '#ff0000'];

        function spawnTetrisPiece() {
            const type = Math.floor(Math.random() * 7) + 1;
            piece = { matrix: shapes[type], x: 4, y: 0, type: type };
            if (collide(board, piece)) { board.forEach(row => row.fill(0)); tScore = 0; showRetroDeathPopup('Tetris', 'La pile a touch√© le plafond.'); } // Game Over
        }
        
        function collide(b, p) {
            for (let y = 0; y < p.matrix.length; ++y) {
                for (let x = 0; x < p.matrix[y].length; ++x) {
                    if (p.matrix[y][x] && (b[y + p.y] && b[y + p.y][x + p.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(b, p) {
            p.matrix.forEach((row, y) => row.forEach((val, x) => { if (val) b[y + p.y][x + p.x] = p.type; }));
        }

        function clearLines() {
            outer: for (let y = ROWS - 1; y >= 0; --y) {
                for (let x = 0; x < COLS; ++x) if (board[y][x] === 0) continue outer;
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row); ++y; tScore += 100;
                if(tScore > gameState.tetrisHigh) { gameState.tetrisHigh = tScore; checkUnlocks(); }
                document.getElementById('tetris-score').innerText = tScore;
                if (tScore >= 1000) claimOneTimeReward('tetrisComplete', 100, 'Tetris termin√©');
            }
        }

        function tetrisLoop() {
            if (currentActiveTab === 'screen-tetris') {
                if (!piece) spawnTetrisPiece();
                if (Date.now() - lastDrop > 500) {
                    piece.y++;
                    if (collide(board, piece)) { piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); }
                    lastDrop = Date.now();
                }
                tCtx.fillStyle = '#000'; tCtx.fillRect(0,0, tCanv.width, tCanv.height);
                drawMatrix(board, 0, 0);
                if (piece) drawMatrix(piece.matrix, piece.x, piece.y);
            }
            requestAnimationFrame(tetrisLoop);
        }

        function drawMatrix(matrix, offsetX, offsetY) {
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val !== 0) {
                        tCtx.fillStyle = colors[val];
                        tCtx.fillRect((x + offsetX) * BLOCK, (y + offsetY) * BLOCK, BLOCK-1, BLOCK-1);
                    }
                });
            });
        }

        document.addEventListener('keydown', e => {
            if (currentActiveTab !== 'screen-tetris' || !piece) return;
            if (e.key === 'ArrowLeft') { piece.x--; if(collide(board, piece)) piece.x++; }
            if (e.key === 'ArrowRight') { piece.x++; if(collide(board, piece)) piece.x--; }
            if (e.key === 'ArrowDown') { piece.y++; if(collide(board, piece)){ piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); } }
            if (e.key === 'ArrowUp') {
                const rot = piece.matrix[0].map((val, index) => piece.matrix.map(row => row[index]).reverse());
                const prev = piece.matrix; piece.matrix = rot;
                if (collide(board, piece)) piece.matrix = prev;
            }
        });

        // ==========================================
        // MINIGAME 2: FLAPPY BIRD
        // ==========================================
        const fCanv = document.getElementById('flappy-canvas');
        const fCtx = fCanv.getContext('2d');
        let bird = { y: 240, v: 0, size: 20 }, pipes = [], fFrames = 0, fScore = 0;
        let explosion = { active: false, x: 0, y: 0, life: 0, particles: [] };

        function jump(e) { if(currentActiveTab === 'screen-flappy') { bird.v = -6; if(e) e.preventDefault(); } }
        document.addEventListener('keydown', e => { if(e.code === 'Space') jump(e); });
        fCanv.addEventListener('mousedown', jump);

        function triggerExplosion(x, y) {
            explosion = {
                active: true,
                x,
                y,
                life: 25,
                particles: Array.from({ length: 16 }, () => ({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: Math.random() * 4 + 2
                }))
            };
        }

        function resetFlappy() {
            fScore = 0;
            bird.y = 240;
            bird.v = 0;
            pipes = [];
            fFrames = 0;
            document.getElementById('flappy-score').innerText = '0';
        }

        function flappyLoop() {
            if (currentActiveTab === 'screen-flappy') {
                bird.v += 0.3; bird.y += bird.v; 
                if(fFrames % 90 === 0) pipes.push({ x: 320, gap: Math.random()*200 + 50, passed: false });
                
                fCtx.fillStyle = '#000'; fCtx.fillRect(0,0, 320, 480);
                fCtx.font = '22px sans-serif';
                fCtx.fillText('‚úàÔ∏è', 50, bird.y + bird.size);

                pipes.forEach((p, i) => {
                    p.x -= 2;
                    fCtx.fillStyle = '#03dac6';
                    fCtx.fillRect(p.x, 0, 40, p.gap); 
                    fCtx.fillRect(p.x, p.gap + 120, 40, 480); 
                    
                    if ((50 < p.x + 40 && 50 + bird.size > p.x && (bird.y < p.gap || bird.y + bird.size > p.gap + 120)) || bird.y > 480 || bird.y < -bird.size) {
                        triggerExplosion(60, bird.y + bird.size / 2);
                        showRetroDeathPopup('Flappy Bird', 'Pipeline fatal. Tu respawn instant.');
                        resetFlappy();
                    }
                    if (!p.passed && p.x + 40 < 50) {
                        p.passed = true;
                        fScore++; document.getElementById('flappy-score').innerText = fScore;
                        if(fScore > gameState.flappyHigh) { gameState.flappyHigh = fScore; checkUnlocks(); }
                        claimFlappyMilestone(fScore);
                        if (fScore === 20) claimOneTimeReward('flappyComplete', 90, 'Module Flappy valid√©');
                    }
                });
                pipes = pipes.filter(p => p.x > -40);

                if (explosion.active) {
                    explosion.particles.forEach(part => {
                        part.x += part.vx;
                        part.y += part.vy;
                        part.size *= 0.94;
                        fCtx.fillStyle = '#ff6b35';
                        fCtx.fillRect(part.x, part.y, Math.max(part.size, 1), Math.max(part.size, 1));
                    });
                    explosion.life--;
                    if (explosion.life <= 0) explosion.active = false;
                }
                fFrames++;
            }
            requestAnimationFrame(flappyLoop);
        }

        // ==========================================
        // MINIGAME 2.5: MEMORY (50 CARDS)
        // ==========================================
        const memoryEmojis = ['üêù','üê±','üê∂','ü¶ä','üêº','üê∏','ü¶Å','üêµ','üêô','ü¶Ñ','üêß','üê¢','üê≥','ü¶ã','üåà','‚≠ê','üî•','üçÄ','üéØ','‚ö°','üçï','üç©','üéà','üöÄ','üéÆ'];
        let memoryCards = [];
        let memoryRevealed = [];
        let memoryMatched = 0;

        function initMemoryGame() {
            const deck = [...memoryEmojis, ...memoryEmojis]
                .map((emoji, i) => ({ id: i, emoji, matched: false }))
                .sort(() => Math.random() - 0.5);
            memoryCards = deck;
            memoryRevealed = [];
            memoryMatched = gameState.memorySolved ? 25 : 0;
            if (gameState.memorySolved) memoryCards.forEach(c => c.matched = true);
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            document.getElementById('memory-matched').innerText = memoryMatched;
            renderMemoryBoard();
        }

        function renderMemoryBoard() {
            const board = document.getElementById('memory-board');
            if (!memoryCards.length) initMemoryGame();
            board.innerHTML = '';
            memoryCards.forEach((card, index) => {
                const btn = document.createElement('button');
                const shown = card.matched || memoryRevealed.includes(index);
                btn.className = `memory-card ${shown ? 'revealed' : ''} ${card.matched ? 'matched' : ''}`;
                btn.innerText = shown ? card.emoji : '‚ùî';
                btn.onclick = () => flipMemoryCard(index);
                if (card.matched) btn.disabled = true;
                board.appendChild(btn);
            });
        }

        function flipMemoryCard(index) {
            const card = memoryCards[index];
            if (!card || card.matched || memoryRevealed.includes(index) || memoryRevealed.length === 2 || gameState.memorySolved) return;
            memoryRevealed.push(index);
            renderMemoryBoard();
            if (memoryRevealed.length < 2) return;
            gameState.memoryAttempts += 1;
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            const [a, b] = memoryRevealed;
            if (memoryCards[a].emoji === memoryCards[b].emoji) {
                memoryCards[a].matched = true;
                memoryCards[b].matched = true;
                memoryMatched += 1;
                document.getElementById('memory-matched').innerText = memoryMatched;
                memoryRevealed = [];
                if (memoryMatched === 25) {
                    gameState.memorySolved = true;
                    gameState.unlockedFlappy = true;
                    checkUnlocks();
                    document.getElementById('slot-result').innerText = 'Memory termin√©, Flappy d√©verrouill√© ‚úÖ';
                    claimOneTimeReward('memoryComplete', 120, 'Memory compl√©t√©');
                }
                renderMemoryBoard();
                return;
            }
            setTimeout(() => { memoryRevealed = []; renderMemoryBoard(); }, 650);
        }

        // ==========================================
        // BONUS: MACHINE A SOUS + ROULETTE + BLACKJACK + POKER
        // ==========================================
        const sCanv = document.getElementById('slot-canvas');
        const sCtx = sCanv.getContext('2d');
        const rCanv = document.getElementById('roulette-canvas');
        const rCtx = rCanv.getContext('2d');
        const slotSymbols = ['üçí', 'üçã', '7Ô∏è‚É£', 'üíé', 'üîî'];
        const rouletteNumbers = Array.from({ length: 37 }, (_, n) => ({
            n,
            color: n === 0 ? 'green' : ([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36].includes(n) ? 'red' : 'black')
        }));
        let rouletteAngle = 0;
        let rouletteBetType = 'red';
        let bjPlayer = [], bjDealer = [], bjDeck = [], bjDone = true, bjBet = 0;

        function getBetValue(inputId, min = 1) {
            const val = Number(document.getElementById(inputId).value);
            return Number.isFinite(val) ? Math.max(min, Math.floor(val)) : min;
        }

        function spendTokens(amount, msgId, gameName) {
            if (gameState.slotTokens < amount) {
                document.getElementById(msgId).innerText = `Pas assez de jetons pour ${gameName} (${amount} requis).`;
                return false;
            }
            gameState.slotTokens -= amount;
            checkUnlocks();
            return true;
        }

        function payoutTokens(amount) {
            gameState.slotTokens += amount;
            checkUnlocks();
        }

        function drawSlot(lastRoll = ['‚ùî', '‚ùî', '‚ùî']) {
            sCtx.fillStyle = '#111827'; sCtx.fillRect(0, 0, sCanv.width, sCanv.height);
            sCtx.fillStyle = '#374151'; sCtx.fillRect(20, 25, 320, 120);
            lastRoll.forEach((sym, i) => {
                sCtx.fillStyle = '#0b1220'; sCtx.fillRect(35 + i * 100, 40, 80, 90);
                sCtx.fillStyle = '#fff'; sCtx.font = '42px sans-serif'; sCtx.fillText(sym, 55 + i * 100, 95);
            });
            sCtx.fillStyle = '#9ca3af'; sCtx.font = '13px sans-serif';
            sCtx.fillText('3 identiques = x5 | 2 identiques = x2 | sinon perdu', 24, 178);
        }

        function spinSlotMachine() {
            const bet = getBetValue('slot-bet');
            if (!spendTokens(bet, 'slot-result', 'la machine √† sous')) return;
            const roll = [0,0,0].map(() => slotSymbols[Math.floor(Math.random() * slotSymbols.length)]);
            drawSlot(roll);
            const uniq = new Set(roll).size;
            let multiplier = 0;
            if (uniq === 1) multiplier = 5; else if (uniq === 2) multiplier = 2;
            const gain = bet * multiplier;
            if (gain > 0) payoutTokens(gain);
            document.getElementById('slot-result').innerText = gain > 0 ? `R√©sultat ${roll.join(' ')}: x${multiplier}, +${gain} jetons` : `R√©sultat ${roll.join(' ')}: perdu.`;
        }

        function drawRoulette(pointer = null) {
            rCtx.clearRect(0, 0, rCanv.width, rCanv.height);
            const cx = 120, cy = 110, r = 86;
            const sliceAngle = (Math.PI * 2) / rouletteNumbers.length;
            rouletteNumbers.forEach((entry, i) => {
                const start = rouletteAngle + i * sliceAngle;
                const mid = start + sliceAngle / 2;
                rCtx.beginPath(); rCtx.moveTo(cx, cy); rCtx.arc(cx, cy, r, start, start + sliceAngle); rCtx.closePath();
                rCtx.fillStyle = entry.color === 'red' ? '#dc2626' : entry.color === 'black' ? '#111827' : '#16a34a';
                rCtx.fill();
                rCtx.fillStyle = '#fff';
                rCtx.font = '8px sans-serif';
                rCtx.fillText(String(entry.n), cx + Math.cos(mid) * 66 - 4, cy + Math.sin(mid) * 66 + 3);
            });
            rCtx.fillStyle = '#fff'; rCtx.beginPath();
            rCtx.moveTo(cx + r + 15, cy); rCtx.lineTo(cx + r + 35, cy - 10); rCtx.lineTo(cx + r + 35, cy + 10);
            rCtx.closePath(); rCtx.fill();
            rCtx.font = '13px sans-serif'; rCtx.fillText(`Mise: ${rouletteBetType.toUpperCase()}`, 225, 45);
            if (pointer !== null) rCtx.fillText(`Num√©ro: ${rouletteNumbers[pointer].n} (${rouletteNumbers[pointer].color})`, 225, 72);
        }

        function setRouletteBetType(type) { rouletteBetType = type; drawRoulette(); }

        function rouletteWin(number, type) {
            if (type === 'red') return number.color === 'red';
            if (type === 'black') return number.color === 'black';
            if (type === 'even') return number.n !== 0 && number.n % 2 === 0;
            if (type === 'odd') return number.n % 2 === 1;
            return false;
        }

        function chooseRouletteIndexCheat(type) {
            const wins = rouletteNumbers.map((n,i)=> rouletteWin(n, type) ? i : -1).filter(i => i >= 0);
            const losses = rouletteNumbers.map((n,i)=> !rouletteWin(n, type) ? i : -1).filter(i => i >= 0);
            const riggedLoseChance = 0.78;
            const pool = Math.random() < riggedLoseChance ? losses : wins;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function spinRoulette() {
            const bet = getBetValue('roulette-bet');
            if (!spendTokens(bet, 'roulette-result', 'la roulette')) return;
            const idx = chooseRouletteIndexCheat(rouletteBetType);
            const sliceAngle = (Math.PI * 2) / rouletteNumbers.length;
            const targetAngle = (Math.PI * 8) + ((rouletteNumbers.length - idx) * sliceAngle);
            const startAngle = rouletteAngle, startTime = performance.now(), duration = 1700;
            function animate(now) {
                const t = Math.min((now - startTime) / duration, 1), eased = 1 - Math.pow(1 - t, 3);
                rouletteAngle = startAngle + (targetAngle - startAngle) * eased; drawRoulette();
                if (t < 1) return requestAnimationFrame(animate);
                const number = rouletteNumbers[idx], won = rouletteWin(number, rouletteBetType);
                if (won) payoutTokens(bet * 2);
                document.getElementById('roulette-result').innerText = won
                    ? `N¬∞${number.n} ${number.color}: gagn√© +${bet * 2} jetons (x2)`
                    : `N¬∞${number.n} ${number.color}: perdu (roulette biais√©e üòà).`;
                drawRoulette(idx);
            }
            requestAnimationFrame(animate);
        }

        const bCanv = document.getElementById('blackjack-canvas');
        const bCtx = bCanv.getContext('2d');
        function newDeck() {
            const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            bjDeck = []; for (let suit = 0; suit < 4; suit++) vals.forEach(v => bjDeck.push(v)); bjDeck.sort(() => Math.random() - 0.5);
        }
        function handValue(hand) {
            let total = 0, aces = 0;
            hand.forEach(v => { if (v === 'A') { total += 11; aces++; } else if (['J','Q','K'].includes(v)) total += 10; else total += Number(v); });
            while (total > 21 && aces-- > 0) total -= 10; return total;
        }
        function drawBlackjack(revealDealer = false) {
            bCtx.fillStyle = '#052e16'; bCtx.fillRect(0,0,bCanv.width,bCanv.height);
            bCtx.fillStyle = '#fff'; bCtx.font = '13px sans-serif';
            bCtx.fillText(`Dealer: ${revealDealer ? handValue(bjDealer) : '?'}`, 10, 18);
            bCtx.fillText(`Player: ${handValue(bjPlayer)}`, 10, 128); bCtx.fillText(`Mise: ${bjBet}`, 255, 18);
            bjDealer.forEach((c, i) => drawCard(20 + i * 45, 28, revealDealer || i === 0 ? c : 'üÇ†'));
            bjPlayer.forEach((c, i) => drawCard(20 + i * 45, 140, c));
        }
        function drawCard(x, y, label) {
            bCtx.fillStyle = '#f8fafc'; bCtx.fillRect(x, y, 38, 56);
            bCtx.strokeStyle = '#111'; bCtx.strokeRect(x, y, 38, 56);
            bCtx.fillStyle = '#111'; bCtx.font = '14px sans-serif'; bCtx.fillText(label, x + 10, y + 32);
        }
        function startBlackjackRound() {
            if (!bjDone) return; bjBet = getBetValue('blackjack-bet');
            if (!spendTokens(bjBet, 'blackjack-result', 'le blackjack')) return;
            newDeck(); bjPlayer = [bjDeck.pop(), bjDeck.pop()]; bjDealer = [bjDeck.pop(), bjDeck.pop()]; bjDone = false;
            document.getElementById('blackjack-result').innerText = 'Main en cours...'; animateBlackjackReveal(0);
        }
        function animateBlackjackReveal(step) { drawBlackjack(false); if (step > 2) return; setTimeout(() => animateBlackjackReveal(step + 1), 120); }
        function blackjackHit() { if (bjDone) return; bjPlayer.push(bjDeck.pop()); drawBlackjack(false); if (handValue(bjPlayer) > 21) finishBlackjack(); }
        function blackjackStand() { if (bjDone) return; while (handValue(bjDealer) < 17) bjDealer.push(bjDeck.pop()); finishBlackjack(); }
        function finishBlackjack() {
            bjDone = true; const p = handValue(bjPlayer), d = handValue(bjDealer); let msg = '√âgalit√©.';
            if (p > 21) msg = 'Bust, perdu.';
            else if (d > 21 || p > d) { payoutTokens(bjBet * 2); msg = `Gagn√© ! +${bjBet * 2} jetons`; }
            else if (p < d) msg = 'Perdu.';
            else { payoutTokens(bjBet); msg = `Push, mise rembours√©e (+${bjBet}).`; }
            document.getElementById('blackjack-result').innerText = msg; drawBlackjack(true);
        }

        function drawCardObj() {
            const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            const suits = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
            return { value: values[Math.floor(Math.random() * values.length)], suit: suits[Math.floor(Math.random() * suits.length)] };
        }
        function cardValue(v) { return ({'J':11,'Q':12,'K':13,'A':14}[v] || Number(v)); }
        function evaluateHand(cards) {
            const vals = cards.map(c => cardValue(c.value)).sort((a,b)=>b-a);
            const suits = cards.map(c => c.suit);
            const counts = {}; vals.forEach(v => counts[v] = (counts[v] || 0) + 1);
            const groups = Object.entries(counts).map(([v,c]) => ({v:Number(v), c})).sort((a,b)=> b.c - a.c || b.v - a.v);
            const flush = suits.every(s => s === suits[0]);
            const unique = [...new Set(vals)].sort((a,b)=>a-b);
            const straight = unique.length === 5 && (unique[4] - unique[0] === 4 || JSON.stringify(unique) === JSON.stringify([2,3,4,5,14]));
            if (straight && flush) return { rank: 8, name: 'Quinte flush', tie: vals };
            if (groups[0].c === 4) return { rank: 7, name: 'Carr√©', tie: [groups[0].v, groups[1].v] };
            if (groups[0].c === 3 && groups[1].c === 2) return { rank: 6, name: 'Full', tie: [groups[0].v, groups[1].v] };
            if (flush) return { rank: 5, name: 'Couleur', tie: vals };
            if (straight) return { rank: 4, name: 'Suite', tie: vals };
            if (groups[0].c === 3) return { rank: 3, name: 'Brelan', tie: [groups[0].v, ...groups.slice(1).map(g=>g.v)] };
            if (groups[0].c === 2 && groups[1].c === 2) return { rank: 2, name: 'Deux paires', tie: [groups[0].v, groups[1].v, groups[2].v] };
            if (groups[0].c === 2) return { rank: 1, name: 'Paire', tie: [groups[0].v, ...groups.slice(1).map(g=>g.v)] };
            return { rank: 0, name: 'Hauteur', tie: vals };
        }
        function compareEval(a,b){
            if (a.rank !== b.rank) return a.rank - b.rank;
            for (let i=0;i<Math.max(a.tie.length,b.tie.length);i++){ const av=a.tie[i]||0,bv=b.tie[i]||0; if(av!==bv) return av-bv; }
            return 0;
        }
        function formatCards(cards){ return cards.map(c => `${c.value}${c.suit}`).join(' '); }

        function playClassicPoker() {
            const bet = getBetValue('classic-poker-bet');
            if (!spendTokens(bet, 'classic-poker-result', 'le poker classique')) return;
            const player = Array.from({length:5}, drawCardObj), dealer = Array.from({length:5}, drawCardObj);
            const pe = evaluateHand(player), de = evaluateHand(dealer), cmp = compareEval(pe, de);
            if (cmp > 0) { payoutTokens(bet * 2); claimOneTimeReward('classicPokerWin', 70, 'Premi√®re victoire Poker classique'); document.getElementById('classic-poker-result').innerText = `Toi [${formatCards(player)}] ${pe.name} > Banque [${formatCards(dealer)}] ${de.name}: +${bet * 2}`; }
            else if (cmp === 0) { payoutTokens(bet); document.getElementById('classic-poker-result').innerText = `√âgalit√© ${pe.name}. Mise rembours√©e.`; }
            else { document.getElementById('classic-poker-result').innerText = `Banque [${formatCards(dealer)}] ${de.name} domine.`; }
        }

        function bestFiveFromSix(cards) {
            let best = null;
            for (let i = 0; i < cards.length; i++) {
                const hand = cards.filter((_, idx) => idx !== i);
                const evald = evaluateHand(hand);
                if (!best || compareEval(evald, best.eval) > 0) best = { hand, eval: evald };
            }
            return best;
        }

        function playPokerUltimate() {
            if (!gameState.unlockedPoker) return document.getElementById('poker-result').innerText = 'Poker Ultimate est verrouill√©.';
            const bet = getBetValue('poker-bet');
            if (!spendTokens(bet, 'poker-result', 'Poker Ultimate')) return;
            const playerSix = Array.from({length:6}, drawCardObj), dealerSix = Array.from({length:6}, drawCardObj);
            const pb = bestFiveFromSix(playerSix), db = bestFiveFromSix(dealerSix);
            const cmp = compareEval(pb.eval, db.eval);
            let payout = 0;
            if (cmp > 0) payout = pb.eval.rank >= 4 ? bet * 4 : bet * 3;
            else if (cmp === 0) payout = bet;
            if (payout > 0) payoutTokens(payout);
            if (cmp > 0) claimOneTimeReward('ultimatePokerWin', 120, 'Premi√®re victoire Poker Ultimate');
            document.getElementById('poker-result').innerText = cmp > 0
                ? `ULTIMATE WIN: [${formatCards(pb.hand)}] ${pb.eval.name} vs [${formatCards(db.hand)}] ${db.eval.name} => +${payout}`
                : cmp === 0
                    ? `√âgalit√© ultimate (${pb.eval.name}), mise rendue.`
                    : `Perdu. Toi [${formatCards(pb.hand)}] ${pb.eval.name} | Banque [${formatCards(db.hand)}] ${db.eval.name}`;
        }

        drawSlot(); drawRoulette(); drawBlackjack(false);

        // ==========================================
        // MINIGAME 3: SWARM SURVIVAL
        // ==========================================
        const dCanv = document.getElementById('dodge-canvas');
        const dCtx = dCanv.getContext('2d');
        let player = { x: 300, y: 200, size: 15 }, enemies = [], dTime = 0, lastTick = Date.now();

        dCanv.addEventListener('mousemove', e => {
            const rect = dCanv.getBoundingClientRect();
            player.x = e.clientX - rect.left; player.y = e.clientY - rect.top;
        });

        function restartSwarmRun() {
            dTime = 0;
            enemies = [];
            player.x = 300;
            player.y = 200;
            document.getElementById('dodge-score').innerText = '0.0';
        }

        function dodgeLoop() {
            if (currentActiveTab === 'screen-final') {
                const now = Date.now(); const dt = now - lastTick; lastTick = now;
                dTime += dt;
                document.getElementById('dodge-score').innerText = (dTime / 1000).toFixed(1);

                // Progressive, but fair, difficulty curve
                let spawnRate = 0.04 + (dTime / 30000) * 0.18;

                if(Math.random() < spawnRate) { 
                    let side = Math.floor(Math.random()*4);
                    let x = side%2===0 ? Math.random()*600 : (side===1?600:0);
                    let y = side%2!==0 ? Math.random()*400 : (side===0?0:400);
                    let angle = Math.atan2(player.y - y, player.x - x);
                    // Enemies become faster over time, but less aggressively
                    let speed = 2 + (dTime / 30000) * 1.6;
                    enemies.push({ x: x, y: y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, size: 8 });
                }

                dCtx.fillStyle = 'rgba(0,0,0,0.3)'; dCtx.fillRect(0,0,600,400); 
                dCtx.fillStyle = '#bb86fc'; dCtx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);

                for (let i = enemies.length-1; i >= 0; i--) {
                    let e = enemies[i];
                    e.x += e.vx; e.y += e.vy;
                    dCtx.fillStyle = '#cf6679'; dCtx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
                    
                    // Hit detection
                    let dist = Math.hypot(player.x - e.x, player.y - e.y);
                    if (dist < (player.size/2 + e.size/2)) {
                        dTime = 0; enemies = []; 
                        showRetroDeathPopup('Swarm Survival', "La nu√©e t'a eu. Clique relancer et retente.");
                        return;
                    }
                    if (e.x < -50 || e.x > 650 || e.y < -50 || e.y > 450) enemies.splice(i, 1);
                }

                if (dTime >= 30000) {
                    claimOneTimeReward('swarmComplete', 180, 'Swarm Survival termin√©');
                    alert("YOU DID IT! You survived the swarm and beat the game!");
                    dTime = 0; enemies = [];
                }
            } else { lastTick = Date.now(); } 
            requestAnimationFrame(dodgeLoop);
        }

        function varColor(name) { return getComputedStyle(document.body).getPropertyValue(name); }
    </script>
</body>
</html>
