<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Empire - Connected Edition</title>
    <style>
        /* --- CSS VARIABLES & RESET --- */
        :root {
            --bg: #121212; --panel: #1e1e1e; --accent: #bb86fc;
            --gold: #ffd700; --red: #cf6679; --green: #03dac6;
            --text: #ffffff; --text-sec: #b0b0b0;
            --panel-soft: #25293a;
            --border-soft: rgba(187, 134, 252, 0.28);
        }

        body {
            margin: 0; padding: 0; font-family: 'Roboto', 'Segoe UI', sans-serif;
            background: radial-gradient(circle at top, #1f263c 0%, #121212 45%);
            color: var(--text);
            min-height: 100vh; overflow-x: hidden; overflow-y: auto; user-select: none; display: flex; flex-direction: column;
        }

        /* --- TABS NAVIGATION --- */
        #tabs-bar {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0, 0, 0, 0.45); backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-soft); gap: 10px; z-index: 5;
        }
        .tabs-group { display: flex; flex-wrap: wrap; gap: 10px; }
        .tab-btn {
            background: #222837; color: var(--text-sec); border: 1px solid #444c61;
            padding: 10px 20px; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: 0.3s;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); box-shadow: 0 0 16px rgba(187, 134, 252, 0.45); }
        .tab-btn:hover:not(.active) { background: #31364b; color: white; }
        .tab-btn.logout { background: transparent; color: #ff8f9f; border-color: rgba(255, 143, 159, 0.6); }
        .tab-btn.logout:hover { background: rgba(255, 143, 159, 0.15); }
        .tab-btn.resume { background: linear-gradient(90deg, #22c55e, #16a34a); color: #03140a; border-color: transparent; }
        .tab-btn.resume:hover { filter: brightness(1.08); color: #03140a; }
        .hidden { display: none !important; }

        .retro-banner {
            position: fixed;
            top: 62px;
            left: 0;
            right: 0;
            z-index: 30;
            background: linear-gradient(90deg, #f97316, #ef4444, #ec4899);
            color: #fff;
            font-size: 0.9rem;
            font-weight: 700;
            white-space: nowrap;
            overflow: hidden;
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            border-bottom: 1px solid rgba(255, 255, 255, 0.25);
        }
        .retro-banner span {
            display: inline-block;
            padding-left: 100%;
            animation: retroScroll 18s linear infinite;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.45);
        }
        @keyframes retroScroll {
            from { transform: translateX(0); }
            to { transform: translateX(-100%); }
        }

        .death-popup {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.72);
            z-index: 40;
        }
        .death-popup-card {
            width: min(92vw, 430px);
            background: linear-gradient(170deg, #26203a 0%, #1a1427 100%);
            border: 2px solid #ffd700;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
            padding: 18px;
            text-align: center;
        }
        .death-popup-card img { width: 100%; border-radius: 10px; margin-bottom: 10px; }
        .death-popup-card h3 { margin: 8px 0; color: var(--gold); }

        /* --- SCREENS --- */
        .screen { display: none; width: 100%; flex: 1; min-height: 0; overflow-y: auto; }
        .screen.active { display: flex; }

        /* --- CLICKER LAYOUT --- */
        #game-layer { display: flex; width: 100%; height: 100%; min-height: 0; transition: filter 0.5s ease; }
        .blurred { filter: blur(20px); pointer-events: none; }
        .game-area { flex: 6; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, #2f3855 0%, #121212 78%); position: relative; }
        .shop-area { flex: 4; background: linear-gradient(170deg, #1e1e2c 0%, #151723 100%); display: flex; flex-direction: column; border-left: 1px solid var(--border-soft); max-width: 450px; }

        /* --- GAME ELEMENTS --- */
        .header-stats { text-align: center; margin-bottom: 20px; z-index: 2; }
        #score { font-size: 4rem; font-weight: 800; color: var(--text); text-shadow: 0 0 20px rgba(187, 134, 252, 0.3); }
        #cps { color: var(--text-sec); font-size: 1.2rem; }
        .prestige-badge { background: linear-gradient(45deg, #FFD700, #FFA500); color: black; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 0.9rem; margin-top: 10px; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); display: inline-block; }
        #cookie { font-size: 200px; cursor: pointer; transition: transform 0.05s; filter: drop-shadow(0 0 30px rgba(0,0,0,0.5)); z-index: 2; }
        #cookie:active { transform: scale(0.95); }
        .goal-text { color: var(--red); font-weight: bold; margin-top: 20px; font-size: 1.1rem; }

        /* --- SHOP & ADMIN --- */
        .shop-header { padding: 20px; background: var(--panel-soft); border-bottom: 1px solid var(--border-soft); display: flex; justify-content: space-between; align-items: center; }
        .shop-content { flex: 1; overflow-y: auto; padding: 10px; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .shop-item { background: #2a3042; margin-bottom: 8px; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; transition: all 0.2s; }
        .shop-item:hover { transform: translateX(-4px); background: #333b52; border-color: var(--border-soft); }
        .item-info h4 { margin: 0; font-size: 1rem; color: var(--text); }
        .item-info p { margin: 4px 0 0; font-size: 0.75rem; color: var(--text-sec); }
        .item-cost { font-weight: bold; color: var(--gold); }
        .buy-btn { background: #202735; border: 1px solid #555; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; min-width: 80px; transition: 0.2s; }
        .can-buy { background: var(--green); color: black; border-color: var(--green); font-weight: bold; }
        .locked { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        #ascend-btn { width: 100%; padding: 20px; background: linear-gradient(45deg, #e94560, #c0392b); color: white; border: none; font-weight: bold; font-size: 1.2rem; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; display: none; }
        #ascend-btn:hover { filter: brightness(1.2); }
        .floater { position: absolute; font-size: 24px; font-weight: bold; color: white; pointer-events: none; animation: floatUp 1s ease-out forwards; }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
        .admin-panel { border-top: 1px solid var(--border-soft); padding: 12px; background: #1b2030; }
        .admin-panel h4 { margin: 0 0 8px; color: var(--gold); }
        .admin-panel input {
            width: 100%; padding: 9px; margin: 6px 0; border-radius: 6px;
            background: #111623; border: 1px solid #3c4560; color: #fff;
        }
        #admin-status { min-height: 20px; color: var(--text-sec); font-size: 0.85rem; margin-top: 6px; }

        /* --- MINIGAME CANVASES --- */
        .canvas-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; gap: 12px; background: #111; padding: 16px 12px 28px; box-sizing: border-box; }
        canvas { border: 2px solid var(--accent); background: #000; box-shadow: 0 0 20px rgba(187,134,252,0.2); }
        .minigame-ui { text-align: center; margin-bottom: 15px; }
        .minigame-ui h2 { margin: 0; color: var(--accent); }
        .minigame-ui p { margin: 5px 0 0 0; color: var(--text-sec); }
        .warning-text { color: var(--red); font-weight: bold; font-size: 1.2rem; text-transform: uppercase; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }


        .relax-lounge {
            width: min(95vw, 1080px);
            display: grid;
            grid-template-columns: 230px 1fr;
            gap: 16px;
            align-items: start;
        }
        .relax-menu {
            background: linear-gradient(170deg, #1a2032 0%, #111625 100%);
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 12px;
        }
        .relax-menu h3 { margin: 0 0 4px; color: var(--accent); }
        .relax-menu-btn {
            border: 1px solid #3a4462;
            border-radius: 10px;
            background: #1f2638;
            color: #dce4ff;
            padding: 10px;
            text-align: left;
            cursor: pointer;
            transition: .25s ease;
            font-weight: 700;
        }
        .relax-menu-btn:hover { background: #2a3248; transform: translateX(3px); }
        .relax-menu-btn.active { background: linear-gradient(90deg, #03dac6, #2dd4bf); color: #03111d; border-color: transparent; box-shadow: 0 6px 18px rgba(3,218,198,0.35); }
        .relax-content { background: rgba(14, 20, 34, 0.78); border: 1px solid rgba(187, 134, 252, 0.22); border-radius: 16px; padding: 14px; }
        .relax-section { display: none; }
        .relax-section.active { display: block; }
        .relax-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 18px; }
        .relax-card {
            background: linear-gradient(165deg, #1a2134 0%, #131a2b 100%);
            border: 1px solid rgba(126, 144, 192, 0.28);
            border-radius: 14px;
            padding: 14px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02), 0 14px 26px rgba(0, 0, 0, 0.3);
        }
        .relax-card h3 { margin: 0 0 8px; color: #57f2df; }
        .relax-card p { margin: 0; color: #c2ccdf; }
        #screen-relax canvas { border-color: #03dac6; border-radius: 10px; box-shadow: 0 0 30px rgba(3,218,198,0.16); }
        .actions-row { display:flex; gap:8px; justify-content:center; margin-top:10px; flex-wrap:wrap; }
        .memory-board {
            display:grid; grid-template-columns: repeat(10, 52px); gap:8px; justify-content:center;
            margin-top: 10px; max-height: 360px; overflow-y: auto; padding: 8px; background: #0d111d; border-radius: 10px; border: 1px solid #2f3855;
        }
        .memory-card { width:52px; height:52px; border-radius:8px; border:1px solid #495170; background:#26304a; color:#fff; font-size:24px; cursor:pointer; transition: transform .2s, background .2s; }
        .memory-card:hover { transform: translateY(-2px); }
        .memory-card.revealed, .memory-card.matched { background:#03dac6; color:#111; }
        .memory-card.matched { cursor:default; opacity:.85; }

        .poker-table-visual {
            width: min(95vw, 760px);
            background: radial-gradient(circle at center, #0f6b44 0%, #08422a 66%, #052817 100%);
            border: 2px solid rgba(255, 215, 0, 0.45);
            border-radius: 26px;
            padding: 16px;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.05), 0 14px 30px rgba(0,0,0,0.45);
        }
        .poker-row { display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; margin: 8px 0; }
        .poker-row strong { color: #fdf3c7; min-width: 90px; text-align: right; }
        .poker-cards { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
        .poker-card {
            width: 54px; height: 78px; border-radius: 8px; border: 1px solid #d3d6dd;
            background: #f8fafc; color: #111827; display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 1.05rem;
        }
        .poker-card.red { color: #b91c1c; }
        .poker-card.back { background: repeating-linear-gradient(45deg, #1d4ed8, #1d4ed8 6px, #0f172a 6px, #0f172a 12px); color: #fff; border-color: #0f172a; }

        @media (max-width: 900px) {
            .relax-lounge { grid-template-columns: 1fr; }
            .relax-menu { position: static; }
        }

        /* --- LOGIN MODAL --- */
        #login-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: rgba(6,8,14,0.8); z-index: 10; }
        .card { background: linear-gradient(170deg, #202434 0%, #161a28 100%); padding: 40px; border-radius: 14px; text-align: center; border: 1px solid var(--border-soft); width: 320px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35); }
        input { width: 90%; padding: 10px; margin: 10px 0; background: #121726; border: 1px solid #39415a; color: white; border-radius: 5px; }
        .btn-main { width: 100%; padding: 12px; background: var(--accent); color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="login-modal">
        <div class="card">
            <h2 style="color: var(--accent)">Swarm Login</h2>
            <p id="login-status" style="color: var(--text-sec); font-size: 0.9rem; margin-bottom: 10px;">Checking connection...</p>
            <input type="text" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <button class="btn-main" onclick="manualLogin()">ENTER SYSTEM</button>
        </div>
    </div>

    <div id="tabs-bar" class="hidden">
        <div class="tabs-group">
            <button id="btn-clicker" class="tab-btn active" onclick="switchTab('screen-clicker', this)">Main Terminal</button>
            <button id="btn-tetris" class="tab-btn hidden" onclick="switchTab('screen-tetris', this)">Tetris (Meilleur: <span id="tetris-high">0</span>)</button>
            <button id="btn-memory" class="tab-btn hidden" onclick="switchTab('screen-memory', this)">Memory 50 cartes (Meilleur: <span id="memory-best">0</span>/25)</button>
            <button id="btn-platformer" class="tab-btn hidden" onclick="switchTab('screen-platformer', this)">Platformer (Objectif: arriv√©e)</button>
            <button id="btn-flappy" class="tab-btn hidden" onclick="switchTab('screen-flappy', this)">Flappy (Meilleur: <span id="flappy-high">0</span>)</button>
            <button id="btn-motus" class="tab-btn hidden" onclick="switchTab('screen-motus', this)">Motus (S√©rie: <span id="motus-best">0</span>)</button>
            <button id="btn-final" class="tab-btn hidden" onclick="switchTab('screen-final', this)">Swarm Survival</button>
            <button id="btn-relax" class="tab-btn" onclick="switchTab('screen-relax', this)">Espace d√©tente</button>
            <button id="btn-poker" class="tab-btn hidden" onclick="switchTab('screen-poker', this)">Poker classique</button>
            <button id="btn-resume" class="tab-btn resume hidden" onclick="resumePausedTab()">‚ñ∂ Reprendre la partie</button>
        </div>
        <button class="tab-btn logout" onclick="logout()">Se d√©connecter</button>
    </div>

    <div id="retro-banner" class="retro-banner hidden"><span id="retro-banner-text"></span></div>

    <div id="screen-clicker" class="screen active">
        <div id="game-layer" class="blurred">
            <div class="game-area">
                <div class="header-stats">
                    <div id="score">0</div>
                    <div id="cps">0 Cookies / Sec</div>
                    <div id="prestige-display" class="prestige-badge hidden">
                        MULTIPLIER: x<span id="mult-val">1</span>
                    </div>
                    <div id="tetris-goal" class="goal-text">Goal: Reach 1,000,000,000 Qa Cookies to unlock the Arcade!</div>
                </div>
                <div id="cookie" onclick="clickCookie(event)">üç™</div>
            </div>

            <div class="shop-area">
                <div class="shop-header">
                    <h3>MARKETPLACE</h3>
                    <small id="wallet">0</small>
                </div>
                <div class="shop-content" id="shop-list"></div>
                <div id="admin-panel" class="admin-panel hidden">
                    <h4>ADMIN - Create account</h4>
                    <input id="admin-email" placeholder="email">
                    <input id="admin-password" type="password" placeholder="password (min 8)">
                    <input id="admin-firstname" placeholder="first name (optional)">
                    <input id="admin-lastname" placeholder="last name (optional)">
                    <button class="buy-btn can-buy" style="width:100%;margin-top:6px" onclick="adminCreateUser()">Create user</button>
                    <div id="admin-status"></div>
                </div>
                <button id="ascend-btn" onclick="ascend()">
                    ‚ö†Ô∏è SYSTEM REBOOT ‚ö†Ô∏è<br>
                    <span style="font-size: 0.7rem; opacity: 0.8">Reset Cookies for x2 Income</span>
                </button>
            </div>
        </div>
    </div>

    <div id="screen-tetris" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>TETRIS</h2>
                <p>Arrow keys to move/rotate. Down to drop. Reach 1000 to unlock next module.</p>
                <h3 style="color:var(--gold)">Score: <span id="tetris-score">0</span></h3>
                <h3 style="color:var(--green)">Prochaine pi√®ce: <span id="tetris-next-piece">-</span></h3>
            </div>
            <canvas id="tetris-canvas" width="240" height="400"></canvas>
        </div>
    </div>


    <div id="screen-memory" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>MEMORY - 50 CARTES</h2>
                <p>Trouve les 25 paires d'√©mojis pour d√©verrouiller Platformer.</p>
                <h3 style="color:var(--gold)">Paires: <span id="memory-matched">0</span>/25</h3>
                <h3>Essais: <span id="memory-attempts">0</span></h3>
            </div>
            <div id="memory-board" class="memory-board"></div>
        </div>
    </div>

    <div id="screen-platformer" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>PLATFORMER</h2>
                <p>Utilise ‚Üê ‚Üí pour bouger et Espace pour sauter. Atteins le drapeau vert.</p>
                <h3 style="color:var(--gold)">√âtat: <span id="platformer-status">En cours...</span></h3>
            </div>
            <canvas id="platformer-canvas" width="600" height="260"></canvas>
            <div class="actions-row">
                <button class="buy-btn can-buy" onclick="resetPlatformer()">Recommencer</button>
            </div>
        </div>
    </div>

    <div id="screen-flappy" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>FLAPPY BIRD</h2>
                <p>Click or Spacebar to jump. Reach 20 to unlock Motus.</p>
                <h3 style="color:var(--gold)">Score: <span id="flappy-score">0</span></h3>
            </div>
            <canvas id="flappy-canvas" width="320" height="480"></canvas>
        </div>
    </div>

    <div id="screen-motus" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>MOTUS</h2>
                <p>Trouve le mot myst√®re (5 lettres) en 6 essais. Liste de mots al√©atoire d√©finie en jeu.</p>
                <h3 style="color:var(--gold)">Motus: <span id="motus-status">Nouveau mot pr√™t</span></h3>
            </div>
            <div class="relax-card" style="width:min(95vw,640px)">
                <p id="motus-history" style="white-space:pre-line; min-height:130px"></p>
                <div class="actions-row">
                    <input id="motus-input" type="text" maxlength="5" placeholder="5 lettres" style="width:120px; text-transform:uppercase;"/>
                    <button class="buy-btn" onclick="submitMotusGuess()">Valider</button>
                    <button class="buy-btn" onclick="resetMotusRound()">Nouveau mot</button>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-relax" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>ESPACE D√âTENTE üé∞üÉè</h2>
                <p>Choisis ton ambiance et navigue entre les jeux depuis le menu lounge.</p>
                <h3 style="color:var(--gold)">Jetons: <span id="slot-tokens">50</span></h3>
                <p id="poker-unlock-hint">Poker classique verrouill√© pour le moment.</p>
            </div>
            <div class="relax-lounge">
                <aside class="relax-menu">
                    <h3>Menu lounge</h3>
                    <button class="relax-menu-btn active" onclick="switchRelaxPanel('relax-games', this)">üéÆ Jeux de casino</button>
                    <button class="relax-menu-btn" onclick="switchRelaxPanel('relax-social', this)">ü§ù Espace social</button>
                    <button class="relax-menu-btn" onclick="switchRelaxPanel('relax-services', this)">‚ú® Services VIP</button>
                </aside>
                <div class="relax-content">
                    <div id="relax-games" class="relax-section active">
                        <div class="relax-grid">
                            <div class="relax-card">
                                <h3>Machine √† sous n√©on</h3>
                                <p id="slot-result">Pr√™t √† lancer</p>
                                <canvas id="slot-canvas" width="360" height="220"></canvas>
                                <div class="actions-row">
                                    <input id="slot-bet" type="number" min="1" value="5" style="width:100px" />
                                    <button class="buy-btn can-buy" onclick="spinSlotMachine()">Lancer</button>
                                </div>
                            </div>
                            <div class="relax-card">
                                <h3>Roulette (Rouge/Noir/Pair/Impair)</h3>
                                <p id="roulette-result">Choisis une mise puis lance.</p>
                                <canvas id="roulette-canvas" width="360" height="220"></canvas>
                                <div class="actions-row" style="margin-bottom:8px; flex-wrap: wrap;">
                                    <button class="buy-btn" onclick="setRouletteBetType('red')">Rouge</button>
                                    <button class="buy-btn" onclick="setRouletteBetType('black')">Noir</button>
                                    <button class="buy-btn" onclick="setRouletteBetType('even')">Pair</button>
                                    <button class="buy-btn" onclick="setRouletteBetType('odd')">Impair</button>
                                </div>
                                <div class="actions-row">
                                    <input id="roulette-bet" type="number" min="1" value="5" style="width:100px" />
                                    <button class="buy-btn can-buy" onclick="spinRoulette()">Miser</button>
                                </div>
                            </div>
                            <div class="relax-card">
                                <h3>Poker classique</h3>
                                <p>Utilise la table d√©di√©e avec cartes visuelles.</p>
                                <div class="actions-row">
                                    <button class="buy-btn" onclick="switchTab('screen-poker', document.getElementById('btn-poker'))">Ouvrir la table</button>
                                </div>
                            </div>
                            <div class="relax-card">
                                <h3>Blackjack</h3>
                                <p id="blackjack-result">Lance une partie.</p>
                                <canvas id="blackjack-canvas" width="360" height="220"></canvas>
                                <div class="actions-row">
                                    <input id="blackjack-bet" type="number" min="1" value="10" style="width:100px" />
                                    <button class="buy-btn" onclick="startBlackjackRound()">Nouvelle main</button>
                                    <button class="buy-btn" onclick="blackjackHit()">Hit</button>
                                    <button class="buy-btn" onclick="blackjackStand()">Stand</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="relax-social" class="relax-section">
                        <div class="relax-grid">
                            <div class="relax-card">
                                <h3>Don de jetons</h3>
                                <p id="donation-result">Transf√®re tes jetons aux joueurs disponibles.</p>
                                <div class="actions-row">
                                    <select id="donation-user" style="width:180px; padding:8px; background:#121726; color:#fff; border:1px solid #39415a; border-radius:6px;"></select>
                                    <input id="donation-amount" type="number" min="1" value="15" style="width:100px" />
                                    <button class="buy-btn" onclick="donateTokens()">Donner</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="relax-services" class="relax-section">
                        <div class="relax-grid">
                            <div class="relax-card">
                                <h3>Suppression des pubs</h3>
                                <p id="ads-result">Retire la banni√®re pub r√©tro d√©finitivement pour ce compte.</p>
                                <div class="actions-row">
                                    <button id="remove-ads-btn" class="buy-btn can-buy" onclick="buyAdRemoval()">Enlever les pubs (10000 jetons)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-poker" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>POKER CLASSIQUE ‚ô†Ô∏è</h2>
                <p>5 cartes contre la banque avec table visuelle.</p>
                <h3 style="color:var(--gold)">Jetons: <span id="poker-tokens">50</span></h3>
            </div>
            <div class="poker-table-visual">
                <h3 style="margin-top:0">Table principale</h3>
                <p id="poker-result">Lance une main pour distribuer 5 cartes.</p>
                <div class="poker-row"><strong>Toi</strong><div id="poker-hero" class="poker-cards"></div></div>
                <div class="poker-row"><strong>Banque</strong><div id="poker-dealer" class="poker-cards"></div></div>
                <div class="actions-row">
                    <input id="poker-bet" type="number" min="1" value="25" style="width:100px" />
                    <button class="buy-btn can-buy" onclick="playClassicPoker()">Distribuer</button>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-final" class="screen">
        <div class="canvas-container">
            <div class="minigame-ui">
                <h2>SWARM SURVIVAL</h2>
                <p class="warning-text">‚ö†Ô∏è DODGE THE SWARM ‚ö†Ô∏è</p>
                <p>Move your mouse to control the blue square. DODGE the red swarm. Survive 30 seconds.</p>
                <h3 style="color:var(--gold)">Time: <span id="dodge-score">0</span>s / 30s</h3>
            </div>
            <canvas id="dodge-canvas" width="600" height="400"></canvas>
            <div class="actions-row" style="margin-top:10px;">
                <button id="restart-dodge" class="buy-btn can-buy" onclick="resetDodge(true)">Relancer</button>
            </div>
        </div>
    </div>

    <script src="/config.js"></script>
    <script>
        const BASE_URL = (window.__APP_CONFIG__ && window.__APP_CONFIG__.API_BASE_URL) || "http://192.168.100.91:3000"; 
        let currentUser = null;
        let saveLoopStarted = false;

        const buildingDefs = [
            { id: 'cursor',  name: 'Better Mouse',   baseCost: 15,      val: 1,      type: 'click' },
            { id: 'grandma', name: 'Grandma',        baseCost: 100,     val: 5,      type: 'auto' },
            { id: 'farm',    name: 'Cookie Farm',    baseCost: 1100,    val: 15,     type: 'auto' },
            { id: 'mine',    name: 'Cookie Mine',    baseCost: 12000,   val: 50,     type: 'auto' },
            { id: 'factory', name: 'Factory',        baseCost: 130000,  val: 150,    type: 'auto' },
            { id: 'bank',    name: 'Bank',           baseCost: 1400000, val: 500,    type: 'auto' },
            { id: 'temple',  name: 'Temple',         baseCost: 20000000,val: 1500,   type: 'auto' },
            { id: 'wiz',     name: 'Wizard Tower',   baseCost: 330000000, val: 5000, type: 'auto' },
            { id: 'ship',    name: 'Shipment',       baseCost: 5100000000, val: 20000, type: 'auto' },
            { id: 'alchemy', name: 'Alchemy Lab',    baseCost: 75000000000, val: 100000, type: 'auto' },
            { id: 'portal',  name: 'Portal',         baseCost: 1000000000000, val: 500000, type: 'auto' },
            { id: 'time',    name: 'Time Machine',   baseCost: 14000000000000, val: 2000000, type: 'auto' }
        ];

        let gameState = {
            cookies: 0, clickBase: 1, autoBase: 0, multiplier: 1, buildings: {},
            unlockedTetris: false, unlockedMemory: false, unlockedPlatformer: false, unlockedFlappy: false, unlockedMotus: false, unlockedFinal: false,
            memorySolved: false, platformerSolved: false, motusSolved: false, memoryAttempts: 0,
            tetrisHigh: 0, flappyHigh: 0, memoryMatched: 0, motusBest: 0, slotTokens: 50, unlockedPoker: false,
            claimedFlappyMilestones: [], completedRewards: {}, donationHistory: [], adsRemoved: false
        };

        buildingDefs.forEach(b => gameState.buildings[b.id] = 0);

        // --- AUTH & NETWORK ---
        window.onload = async function() {
            try {
                const response = await fetch(`${BASE_URL}/api/auth/me`, { method: "GET", credentials: "include" });
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('login-status').innerText = "Session found! Loading...";
                    await startGame(data);
                } else { document.getElementById('login-status').innerText = "Please log in."; }
            } catch (error) { document.getElementById('login-status').innerText = "Cannot connect to server."; }
        };

        async function manualLogin() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const statusText = document.getElementById('login-status');
            if (!email || !pass) return statusText.innerText = "Please enter email and password.";
            statusText.innerText = "Authenticating...";

            try {
                const response = await fetch(`${BASE_URL}/api/auth/login`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ email: email.trim(), password: pass })
                });
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.error || "Invalid credentials");
                }
                await startGame(await response.json());
            } catch (error) { statusText.innerText = `Login Failed: ${error.message || "UNKNOWN"}`; }
        }

        async function logout() {
            try {
                await fetch(`${BASE_URL}/api/auth/logout`, { method: 'POST', credentials: 'include' });
            } catch (error) {
                console.warn('Logout request failed, clearing local session only.');
            }

            currentUser = null;
            document.getElementById('login-modal').classList.remove('hidden');
            document.getElementById('game-layer').classList.add('blurred');
            document.getElementById('tabs-bar').classList.add('hidden');
            document.getElementById('admin-panel').classList.add('hidden');
            document.getElementById('login-status').innerText = "Session closed. Please log in.";
        }

        async function startGame(data) {
            currentUser = data?.user || null;
            await loadGameState();
            
            document.getElementById('login-modal').classList.add('hidden');
            document.getElementById('game-layer').classList.remove('blurred');
            document.getElementById('tabs-bar').classList.remove('hidden');
            document.getElementById('admin-panel').classList.toggle('hidden', currentUser?.role !== "ADMIN");
            
            if (gameState.multiplier > 1) {
                document.getElementById('prestige-display').classList.remove('hidden');
                document.getElementById('mult-val').innerText = gameState.multiplier;
            }

            checkUnlocks();
            renderShop();
            updateUI();
            
            if (!saveLoopStarted) {
                setInterval(autoLoop, 1000);
                setInterval(saveGame, 10000); 
                saveLoopStarted = true;
                
                requestAnimationFrame(tetrisLoop);
                initRetroBanner();
                refreshDonationUsers();
                requestAnimationFrame(flappyLoop);
                requestAnimationFrame(platformerLoop);
                requestAnimationFrame(dodgeLoop);
            }
            initMemoryGame();
            resetPlatformer();
            resetMotusRound();
        }

        async function loadGameState() {
            try {
                const response = await fetch(`${BASE_URL}/api/game/state`, { method: "GET", credentials: "include" });
                if (!response.ok) return;
                const data = await response.json();
                if (!data?.gameState) return;
                
                gameState.cookies = Number(data.gameState.cookies ?? 0);
                gameState.clickBase = Number(data.gameState.clickBase ?? 1);
                gameState.autoBase = Number(data.gameState.autoBase ?? 0);
                gameState.multiplier = Number(data.gameState.multiplier ?? 1);
                gameState.buildings = data.gameState.buildings || {};
                
                gameState.unlockedTetris = data.gameState.unlockedTetris || false;
                gameState.unlockedMemory = data.gameState.unlockedMemory || false;
                gameState.unlockedPlatformer = data.gameState.unlockedPlatformer || false;
                gameState.unlockedFlappy = data.gameState.unlockedFlappy || false;
                gameState.unlockedMotus = data.gameState.unlockedMotus || false;
                gameState.unlockedFinal = data.gameState.unlockedFinal || false;
                gameState.memorySolved = data.gameState.memorySolved || false;
                gameState.platformerSolved = Boolean(data.gameState.platformerSolved || false);
                gameState.motusSolved = Boolean(data.gameState.motusSolved || false);
                gameState.memoryAttempts = Number(data.gameState.memoryAttempts ?? 0);
                gameState.tetrisHigh = data.gameState.tetrisHigh || 0;
                gameState.flappyHigh = data.gameState.flappyHigh || 0;
                gameState.memoryMatched = Number(data.gameState.memoryMatched ?? 0);
                gameState.motusBest = Number(data.gameState.motusBest ?? 0);
                gameState.slotTokens = Number(data.gameState.slotTokens ?? 50);
                gameState.unlockedPoker = Boolean(data.gameState.unlockedPoker ?? false);
                gameState.claimedFlappyMilestones = Array.isArray(data.gameState.claimedFlappyMilestones) ? data.gameState.claimedFlappyMilestones : [];
                gameState.completedRewards = data.gameState.completedRewards || {};
                gameState.donationHistory = Array.isArray(data.gameState.donationHistory) ? data.gameState.donationHistory : [];
                gameState.adsRemoved = Boolean(data.gameState.adsRemoved ?? false);

                buildingDefs.forEach(b => { if (typeof gameState.buildings[b.id] !== "number") gameState.buildings[b.id] = 0; });
            } catch (error) { console.error("Failed to load game state"); }
        }

        async function saveGame() {
            if (!currentUser) return;
            try {
                await fetch(`${BASE_URL}/api/game/save`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    credentials: "include", body: JSON.stringify({ state: gameState })
                });
            } catch (error) {}
        }

        async function adminCreateUser() {
            if (!currentUser || currentUser.role !== "ADMIN") return;
            const status = document.getElementById("admin-status");
            const email = document.getElementById("admin-email").value.trim();
            const password = document.getElementById("admin-password").value;
            const firstName = document.getElementById("admin-firstname").value.trim();
            const lastName = document.getElementById("admin-lastname").value.trim();

            status.innerText = "Creating...";
            try {
                const response = await fetch(`${BASE_URL}/api/admin/users`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify({
                        email,
                        password,
                        ...(firstName ? { firstName } : {}),
                        ...(lastName ? { lastName } : {})
                    })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data.error || "CREATE_FAILED");
                }
                status.style.color = "var(--green)";
                status.innerText = `Created: ${data.user.email}`;
                document.getElementById("admin-email").value = "";
                document.getElementById("admin-password").value = "";
                document.getElementById("admin-firstname").value = "";
                document.getElementById("admin-lastname").value = "";
            } catch (error) {
                status.style.color = "var(--red)";
                status.innerText = `Failed: ${error.message || "UNKNOWN"}`;
            }
        }

        // --- TAB LOGIC ---
        let currentActiveTab = 'screen-clicker';
        let pausedTab = null;
        let pausedBySwitch = false;
        function switchTab(screenId, btnElement) {
            if (screenId !== currentActiveTab && isPlayableTab(currentActiveTab) && !pausedBySwitch) {
                pausedTab = currentActiveTab;
                currentActiveTab = null;
                document.getElementById('btn-resume').classList.remove('hidden');
            }
            pausedBySwitch = false;
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            btnElement.classList.add('active');
            currentActiveTab = screenId;
            if (screenId === pausedTab) {
                pausedTab = null;
                document.getElementById('btn-resume').classList.add('hidden');
            }
            if (screenId === 'screen-memory') renderMemoryBoard();
            if (screenId === 'screen-motus') renderMotusHistory();
            if (screenId === 'screen-relax') switchRelaxPanel('relax-games');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function isPlayableTab(tabId) {
            return ['screen-tetris', 'screen-platformer', 'screen-flappy', 'screen-motus', 'screen-final'].includes(tabId);
        }

        function resumePausedTab() {
            if (!pausedTab) return;
            const targetButton = document.querySelector(`.tab-btn[onclick*="'${pausedTab}'"]`);
            if (!targetButton) return;
            pausedBySwitch = true;
            switchTab(pausedTab, targetButton);
        }

        function switchRelaxPanel(sectionId, button = null) {
            document.querySelectorAll('.relax-section').forEach(section => section.classList.remove('active'));
            document.querySelectorAll('.relax-menu-btn').forEach(btn => btn.classList.remove('active'));
            const target = document.getElementById(sectionId);
            if (target) target.classList.add('active');
            if (button) button.classList.add('active');
            else {
                const first = document.querySelector(`.relax-menu-btn[onclick*="${sectionId}"]`);
                if (first) first.classList.add('active');
            }
        }

        function checkUnlocks() {
            // 1e24 = 1 Septillion = 1,000,000,000 Quadrillion (Qa)
            if (gameState.cookies >= 1e24) {
                gameState.unlockedTetris = true;
                document.getElementById('tetris-goal').classList.add('hidden');
            } else if (!gameState.unlockedTetris) {
                document.getElementById('tetris-goal').classList.remove('hidden');
            }

            if (gameState.tetrisHigh >= 1000) gameState.unlockedMemory = true;
            if (gameState.memorySolved) gameState.unlockedPlatformer = true;
            if (gameState.platformerSolved) gameState.unlockedFlappy = true;
            if (gameState.flappyHigh >= 20) gameState.unlockedMotus = true;
            if (gameState.motusSolved) gameState.unlockedFinal = true;

            if (gameState.unlockedTetris) document.getElementById('btn-tetris').classList.remove('hidden');
            else document.getElementById('btn-tetris').classList.add('hidden');

            if (gameState.unlockedMemory) document.getElementById('btn-memory').classList.remove('hidden');
            else document.getElementById('btn-memory').classList.add('hidden');

            if (gameState.unlockedPlatformer) document.getElementById('btn-platformer').classList.remove('hidden');
            else document.getElementById('btn-platformer').classList.add('hidden');

            if (gameState.unlockedFlappy) document.getElementById('btn-flappy').classList.remove('hidden');
            else document.getElementById('btn-flappy').classList.add('hidden');

            if (gameState.unlockedMotus) document.getElementById('btn-motus').classList.remove('hidden');
            else document.getElementById('btn-motus').classList.add('hidden');

            if (gameState.unlockedFinal) document.getElementById('btn-final').classList.remove('hidden');
            else document.getElementById('btn-final').classList.add('hidden');

            if (gameState.unlockedMotus) gameState.unlockedPoker = true;
            document.getElementById('btn-poker').classList.toggle('hidden', !gameState.unlockedPoker);
            document.getElementById('poker-unlock-hint').innerText = gameState.unlockedPoker ? 'Poker classique d√©bloqu√© ‚úÖ' : 'Termine Motus pour d√©bloquer le poker classique.';
            document.getElementById('tetris-high').innerText = gameState.tetrisHigh;
            document.getElementById('flappy-high').innerText = gameState.flappyHigh;
            document.getElementById('memory-best').innerText = gameState.memoryMatched || 0;
            document.getElementById('motus-best').innerText = gameState.motusBest || 0;
            document.getElementById('slot-tokens').innerText = gameState.slotTokens;
            document.getElementById('poker-tokens').innerText = gameState.slotTokens;
            const adBtn = document.getElementById('remove-ads-btn');
            const adMsg = document.getElementById('ads-result');
            adBtn.disabled = gameState.adsRemoved;
            adBtn.classList.toggle('cannot-buy', gameState.adsRemoved);
            adBtn.classList.toggle('can-buy', !gameState.adsRemoved);
            adBtn.innerText = gameState.adsRemoved ? 'Pubs retir√©es ‚úÖ' : 'Enlever les pubs (10000 jetons)';
            if (gameState.adsRemoved) adMsg.innerText = 'Retrait des pubs actif pour ce compte.';
            refreshDonationUsers();
        }


        function initRetroBanner() {
            const banner = document.getElementById('retro-banner');
            if (gameState.adsRemoved) {
                banner.classList.add('hidden');
                return;
            }
            banner.classList.remove('hidden');
            const messages = [
                "üî• De beaux inconnus te cherchent √† 2 rues: soir√©e n√©on, poker et confidences jusqu'√† minuit‚Ä¶",
                "üíã Notification locale: un gentleman myst√©rieux veut te d√©fier √† la roulette (et peut-√™tre t'offrir un cocktail).",
                "üåô Ambiance 2010: SMS secret re√ßu ‚Äî \"retrouve-moi pr√®s du casino, tenue chic exig√©e\".",
                "üé≤ Sc√©nario TORRIDE (PG-13): regards insistants, jackpots et rendez-vous impr√©vu juste apr√®s ta victoire."
            ];
            let idx = 0;
            const text = document.getElementById('retro-banner-text');
            text.innerText = messages[idx];
            setInterval(() => {
                idx = (idx + 1) % messages.length;
                text.innerText = messages[idx];
            }, 9000);
        }

        function rewardCompletion(gameKey, amount, message) {
            if (gameState.completedRewards[gameKey]) return;
            gameState.completedRewards[gameKey] = true;
            payoutTokens(amount);
            alert(`R√©compense d√©bloqu√©e: +${amount} jetons (${message})`);
        }

        function triggerRetroDeathPopup(gameName) {
            const seeds = ['neon-arcade', 'retro-pixel', 'vhs-party', 'cyber-heart', 'arcade-rush'];
            const seed = seeds[Math.floor(Math.random() * seeds.length)];
            const overlay = document.createElement('div');
            overlay.className = 'death-popup';
            overlay.innerHTML = `
                <div class="death-popup-card">
                    <img src="https://picsum.photos/seed/${seed}/420/220" alt="retro" />
                    <h3>${gameName}: GAME OVER</h3>
                    <p>üíæ Continue ? Les ann√©es 2010 veulent ton revanche.</p>
                    <button class="buy-btn can-buy" id="close-popup">Relancer</button>
                </div>`;
            document.body.appendChild(overlay);
            overlay.querySelector('#close-popup').onclick = () => overlay.remove();
        }

        
        function buyAdRemoval() {
            const msgEl = document.getElementById('ads-result');
            if (gameState.adsRemoved) {
                msgEl.innerText = 'Les pubs sont d√©j√† d√©sactiv√©es ‚úÖ';
                return;
            }
            if (!spendTokens(10000, 'ads-result', 'la suppression des pubs')) return;
            gameState.adsRemoved = true;
            document.getElementById('retro-banner').classList.add('hidden');
            msgEl.innerText = 'Pubs retir√©es avec succ√®s ‚úÖ';
            checkUnlocks();
            saveGame();
        }

        function refreshDonationUsers() {
            const select = document.getElementById('donation-user');
            if (!select) return;
            const current = currentUser?.email || 'player@swarm.io';
            const available = [
                'neo@swarm.io',
                'luna@swarm.io',
                'ace@swarm.io',
                'pixel@swarm.io'
            ].filter(u => u !== current);
            const prev = select.value;
            select.innerHTML = available.map(u => `<option value="${u}">${u}</option>`).join('');
            if (available.includes(prev)) select.value = prev;
        }

        function donateTokens() {
            const target = document.getElementById('donation-user').value;
            const amount = getBetValue('donation-amount');
            if (!target) return;
            if (!spendTokens(amount, 'donation-result', 'un don')) return;
            gameState.donationHistory.push({ to: target, amount, at: Date.now() });
            document.getElementById('donation-result').innerText = `Don envoy√© √† ${target}: ${amount} jetons.`;
        }

        // --- CORE CLICKER ---
        function clickCookie(e) {
            let amount = gameState.clickBase * gameState.multiplier;
            gameState.cookies += amount;
            spawnFloater(e.clientX, e.clientY, "+" + formatNumber(amount));
            updateUI();
        }

        function autoLoop() {
            if (gameState.autoBase > 0) {
                gameState.cookies += (gameState.autoBase * gameState.multiplier);
                updateUI();
            }
        }

        function ascend() {
            if (gameState.cookies < 10000) return;
            if(!confirm("REBOOT SYSTEM? \n\nYou lose cookies & buildings. Gain permanent x2 Income.")) return;
            gameState.multiplier *= 2; gameState.cookies = 0; gameState.clickBase = 1; gameState.autoBase = 0;
            buildingDefs.forEach(b => gameState.buildings[b.id] = 0);
            document.getElementById('prestige-display').classList.remove('hidden');
            document.getElementById('mult-val').innerText = gameState.multiplier;
            document.getElementById('ascend-btn').style.display = 'none';
            renderShop(); updateUI(); saveGame(); 
        }

        function buy(id) {
            const item = buildingDefs.find(b => b.id === id);
            const cost = getCost(item);
            if (gameState.cookies >= cost) {
                gameState.cookies -= cost; gameState.buildings[id]++;
                if (item.type === 'click') gameState.clickBase += item.val;
                if (item.type === 'auto')  gameState.autoBase += item.val;
                updateUI(); renderShop(); 
            }
        }

        function getCost(item) { return Math.floor(item.baseCost * Math.pow(1.15, gameState.buildings[item.id])); }

        function renderShop() {
            const list = document.getElementById('shop-list');
            list.innerHTML = ""; 
            buildingDefs.forEach(item => {
                const cost = getCost(item); const count = gameState.buildings[item.id];
                const canAfford = gameState.cookies >= cost;
                list.innerHTML += `
                    <div class="shop-item">
                        <div class="item-info">
                            <h4>${item.name} <span style="color:#666; font-size:0.8em">x${count}</span></h4>
                            <p>+${formatNumber(item.val * gameState.multiplier)} ${item.type === 'click' ? 'Click' : '/ sec'}</p>
                            <div class="item-cost">üç™ ${formatNumber(cost)}</div>
                        </div>
                        <button class="buy-btn ${canAfford ? 'can-buy' : 'locked'}" onclick="buy('${item.id}')">BUY</button>
                    </div>
                `;
            });
        }

        function updateUI() {
            document.getElementById('score').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('wallet').innerText = formatNumber(Math.floor(gameState.cookies));
            document.getElementById('cps').innerText = formatNumber(gameState.autoBase * gameState.multiplier) + " / Sec";
            document.getElementById('ascend-btn').style.display = gameState.cookies >= 10000 ? 'block' : 'none';

            const buttons = document.querySelectorAll('.buy-btn');
            buildingDefs.forEach((item, i) => {
                if(buttons[i]) buttons[i].className = `buy-btn ${gameState.cookies >= getCost(item) ? 'can-buy' : 'locked'}`;
            });
            checkUnlocks();
        }

        // --- UPDATED NUMBER FORMATTER ---
        function formatNumber(num) {
            if (num >= 1e27) return (num / 1e27).toFixed(2) + 'Oc'; // Octillion
            if (num >= 1e24) return (num / 1e24).toFixed(2) + 'Sp'; // Septillion (1,000,000,000 Qa)
            if (num >= 1e21) return (num / 1e21).toFixed(2) + 'Sx'; // Sextillion
            if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillion
            if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Qa'; // Quadrillion
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillion
            if (num >= 1e9)  return (num / 1e9).toFixed(2) + 'B';   // Billion
            if (num >= 1e6)  return (num / 1e6).toFixed(2) + 'M';   // Million
            if (num >= 1e3)  return (num / 1e3).toFixed(2) + 'k';   // Thousand
            return Math.floor(num).toString();
        }

        function spawnFloater(x, y, text) {
            const el = document.createElement('div');
            el.innerText = text; el.className = 'floater';
            el.style.left = (x - 20) + "px"; el.style.top = (y - 50) + "px";
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // ==========================================
        // MINIGAME 1: TETRIS
        // ==========================================
        const tCanv = document.getElementById('tetris-canvas');
        const tCtx = tCanv.getContext('2d');
        const COLS = 12, ROWS = 20, BLOCK = 20;
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let piece = null, nextPieceType = null, tScore = 0, lastDrop = Date.now();
        const shapes = [ [],
            [[1,1,1,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]],
            [[1,1],[1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]]
        ];
        const colors = [null, '#00ffff', '#0000ff', '#ffa500', '#ffff00', '#00ff00', '#800080', '#ff0000'];

        function randomTetrisType() {
            return Math.floor(Math.random() * 7) + 1;
        }

        function updateNextPieceLabel() {
            document.getElementById('tetris-next-piece').innerText = nextPieceType ? `Type ${nextPieceType}` : '-';
        }

        function spawnTetrisPiece() {
            if (!nextPieceType) nextPieceType = randomTetrisType();
            const type = nextPieceType;
            nextPieceType = randomTetrisType();
            piece = { matrix: shapes[type], x: 4, y: 0, type: type };
            updateNextPieceLabel();
            if (collide(board, piece)) { board.forEach(row => row.fill(0)); tScore = 0; triggerRetroDeathPopup('Tetris'); } // Game Over
        }
        
        function collide(b, p) {
            for (let y = 0; y < p.matrix.length; ++y) {
                for (let x = 0; x < p.matrix[y].length; ++x) {
                    if (p.matrix[y][x] && (b[y + p.y] && b[y + p.y][x + p.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(b, p) {
            p.matrix.forEach((row, y) => row.forEach((val, x) => { if (val) b[y + p.y][x + p.x] = p.type; }));
        }

        function clearLines() {
            outer: for (let y = ROWS - 1; y >= 0; --y) {
                for (let x = 0; x < COLS; ++x) if (board[y][x] === 0) continue outer;
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row); ++y; tScore += 100;
                payoutTokens(1);
                if(tScore > gameState.tetrisHigh) { gameState.tetrisHigh = tScore; checkUnlocks(); }
                document.getElementById('tetris-score').innerText = tScore;
            }
        }

        function tetrisLoop() {
            if (currentActiveTab === 'screen-tetris') {
                if (!piece) spawnTetrisPiece();
                if (Date.now() - lastDrop > 500) {
                    piece.y++;
                    if (collide(board, piece)) { piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); }
                    lastDrop = Date.now();
                }
                tCtx.fillStyle = '#000'; tCtx.fillRect(0,0, tCanv.width, tCanv.height);
                drawMatrix(board, 0, 0);
                if (piece) drawMatrix(piece.matrix, piece.x, piece.y);
            }
            requestAnimationFrame(tetrisLoop);
        }

        function drawMatrix(matrix, offsetX, offsetY) {
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val !== 0) {
                        tCtx.fillStyle = colors[val];
                        tCtx.fillRect((x + offsetX) * BLOCK, (y + offsetY) * BLOCK, BLOCK-1, BLOCK-1);
                    }
                });
            });
        }

        document.addEventListener('keydown', e => {
            if (currentActiveTab !== 'screen-tetris' || !piece) return;
            if (e.key === 'ArrowLeft') { piece.x--; if(collide(board, piece)) piece.x++; }
            if (e.key === 'ArrowRight') { piece.x++; if(collide(board, piece)) piece.x--; }
            if (e.key === 'ArrowDown') { piece.y++; if(collide(board, piece)){ piece.y--; merge(board, piece); clearLines(); spawnTetrisPiece(); } }
            if (e.key === 'ArrowUp') {
                const rot = piece.matrix[0].map((val, index) => piece.matrix.map(row => row[index]).reverse());
                const prev = piece.matrix; piece.matrix = rot;
                if (collide(board, piece)) piece.matrix = prev;
            }
        });

        // ==========================================
        // MINIGAME 2: FLAPPY BIRD
        // ==========================================
        const fCanv = document.getElementById('flappy-canvas');
        const fCtx = fCanv.getContext('2d');
        let bird = { y: 240, v: 0, size: 20 }, pipes = [], fFrames = 0, fScore = 0;
        let flappyStarted = false;
        let explosion = { active: false, x: 0, y: 0, life: 0, particles: [] };

        function jump(e) {
            if(currentActiveTab === 'screen-flappy') {
                flappyStarted = true;
                bird.v = -6;
                if(e) e.preventDefault();
            }
        }
        document.addEventListener('keydown', e => { if(e.code === 'Space') jump(e); });
        fCanv.addEventListener('mousedown', jump);

        function triggerExplosion(x, y) {
            explosion = {
                active: true,
                x,
                y,
                life: 25,
                particles: Array.from({ length: 16 }, () => ({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: Math.random() * 4 + 2
                }))
            };
        }

        function resetFlappy() {
            fScore = 0;
            bird.y = 240;
            bird.v = 0;
            pipes = [];
            fFrames = 0;
            flappyStarted = false;
            document.getElementById('flappy-score').innerText = '0';
        }

        function flappyLoop() {
            if (currentActiveTab === 'screen-flappy') {
                fCtx.fillStyle = '#000'; fCtx.fillRect(0,0, 320, 480);
                fCtx.font = '22px sans-serif';

                if (!flappyStarted) {
                    bird.v = 0;
                    bird.y = 240;
                    fCtx.fillText('‚úàÔ∏è', 50, bird.y + bird.size);
                    fCtx.font = '18px sans-serif';
                    fCtx.fillStyle = '#ffffff';
                    fCtx.fillText('Clique ou espace pour commencer', 18, 60);
                    requestAnimationFrame(flappyLoop);
                    return;
                }

                bird.v += 0.3; bird.y += bird.v; 
                if(fFrames % 90 === 0) pipes.push({ x: 320, gap: Math.random()*200 + 50, passed: false });
                
                fCtx.fillText('‚úàÔ∏è', 50, bird.y + bird.size);

                pipes.forEach((p, i) => {
                    p.x -= 2;
                    fCtx.fillStyle = '#03dac6';
                    fCtx.fillRect(p.x, 0, 40, p.gap); 
                    fCtx.fillRect(p.x, p.gap + 120, 40, 480); 
                    
                    if ((50 < p.x + 40 && 50 + bird.size > p.x && (bird.y < p.gap || bird.y + bird.size > p.gap + 120)) || bird.y > 480 || bird.y < -bird.size) {
                        triggerExplosion(60, bird.y + bird.size / 2);
                        triggerRetroDeathPopup('Flappy Bird');
                        resetFlappy();
                    }
                    if (!p.passed && p.x + 40 < 50) {
                        p.passed = true;
                        fScore++; document.getElementById('flappy-score').innerText = fScore;
                        if(fScore > gameState.flappyHigh) { gameState.flappyHigh = fScore; checkUnlocks(); }
                        if (fScore % 10 === 0) payoutTokens(1);
                    }
                });
                pipes = pipes.filter(p => p.x > -40);

                if (explosion.active) {
                    explosion.particles.forEach(part => {
                        part.x += part.vx;
                        part.y += part.vy;
                        part.size *= 0.94;
                        fCtx.fillStyle = '#ff6b35';
                        fCtx.fillRect(part.x, part.y, Math.max(part.size, 1), Math.max(part.size, 1));
                    });
                    explosion.life--;
                    if (explosion.life <= 0) explosion.active = false;
                }
                fFrames++;
            }
            requestAnimationFrame(flappyLoop);
        }

        // ==========================================
        // MINIGAME 2.5: MEMORY (50 CARDS)
        // ==========================================
        const memoryEmojis = ['üêù','üê±','üê∂','ü¶ä','üêº','üê∏','ü¶Å','üêµ','üêô','ü¶Ñ','üêß','üê¢','üê≥','ü¶ã','üåà','‚≠ê','üî•','üçÄ','üéØ','‚ö°','üçï','üç©','üéà','üöÄ','üéÆ'];
        let memoryCards = [];
        let memoryRevealed = [];
        let memoryMatched = 0;

        function initMemoryGame() {
            const deck = [...memoryEmojis, ...memoryEmojis]
                .map((emoji, i) => ({ id: i, emoji, matched: false }))
                .sort(() => Math.random() - 0.5);
            memoryCards = deck;
            memoryRevealed = [];
            memoryMatched = gameState.memorySolved ? 25 : 0;
            if (gameState.memorySolved) memoryCards.forEach(c => c.matched = true);
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            document.getElementById('memory-matched').innerText = memoryMatched;
            renderMemoryBoard();
        }

        function renderMemoryBoard() {
            const board = document.getElementById('memory-board');
            if (!memoryCards.length) initMemoryGame();
            board.innerHTML = '';
            memoryCards.forEach((card, index) => {
                const btn = document.createElement('button');
                const shown = card.matched || memoryRevealed.includes(index);
                btn.className = `memory-card ${shown ? 'revealed' : ''} ${card.matched ? 'matched' : ''}`;
                btn.innerText = shown ? card.emoji : '‚ùî';
                btn.onclick = () => flipMemoryCard(index);
                if (card.matched) btn.disabled = true;
                board.appendChild(btn);
            });
        }

        function flipMemoryCard(index) {
            const card = memoryCards[index];
            if (!card || card.matched || memoryRevealed.includes(index) || memoryRevealed.length === 2 || gameState.memorySolved) return;
            memoryRevealed.push(index);
            renderMemoryBoard();
            if (memoryRevealed.length < 2) return;
            gameState.memoryAttempts += 1;
            document.getElementById('memory-attempts').innerText = gameState.memoryAttempts;
            const [a, b] = memoryRevealed;
            if (memoryCards[a].emoji === memoryCards[b].emoji) {
                memoryCards[a].matched = true;
                memoryCards[b].matched = true;
                memoryMatched += 1;
                gameState.memoryMatched = Math.max(gameState.memoryMatched || 0, memoryMatched);
                document.getElementById('memory-matched').innerText = memoryMatched;
                memoryRevealed = [];
                if (memoryMatched === 25) {
                    gameState.memorySolved = true;
                    gameState.unlockedPlatformer = true;
                    checkUnlocks();
                    document.getElementById('slot-result').innerText = 'Memory termin√©, Platformer d√©verrouill√© ‚úÖ';
                    rewardCompletion('memory', 10, 'Memory termin√©');
                }
                renderMemoryBoard();
                return;
            }
            setTimeout(() => { memoryRevealed = []; renderMemoryBoard(); }, 650);
        }


        // ==========================================
        // MINIGAME 2.6: PLATFORMER
        // ==========================================
        const pCanv = document.getElementById('platformer-canvas');
        const pCtx = pCanv.getContext('2d');
        let platPlayer = { x: 20, y: 210, w: 16, h: 16, vx: 0, vy: 0, onGround: false };
        const platKeys = { left: false, right: false, jump: false };
        const platPlatforms = [
            { x: 0, y: 235, w: 600, h: 25 },
            { x: 110, y: 200, w: 90, h: 12 },
            { x: 250, y: 165, w: 90, h: 12 },
            { x: 390, y: 130, w: 90, h: 12 },
            { x: 520, y: 98, w: 70, h: 12 }
        ];
        function resetPlatformer() {
            platPlayer = { x: 20, y: 210, w: 16, h: 16, vx: 0, vy: 0, onGround: false };
            document.getElementById('platformer-status').innerText = gameState.platformerSolved ? 'D√©j√† r√©ussi ‚úÖ' : 'En cours...';
        }
        function platformerLoop() {
            if (currentActiveTab === 'screen-platformer') {
                platPlayer.vx = (platKeys.right ? 2.4 : 0) - (platKeys.left ? 2.4 : 0);
                platPlayer.vy += 0.32;
                if (platKeys.jump && platPlayer.onGround) { platPlayer.vy = -7.2; platPlayer.onGround = false; }
                platPlayer.x += platPlayer.vx;
                platPlayer.y += platPlayer.vy;
                platPlayer.onGround = false;
                platPlatforms.forEach(pl => {
                    const hitX = platPlayer.x < pl.x + pl.w && platPlayer.x + platPlayer.w > pl.x;
                    const hitY = platPlayer.y + platPlayer.h >= pl.y && platPlayer.y + platPlayer.h <= pl.y + 12;
                    if (hitX && hitY && platPlayer.vy >= 0) {
                        platPlayer.y = pl.y - platPlayer.h;
                        platPlayer.vy = 0;
                        platPlayer.onGround = true;
                    }
                });
                if (platPlayer.y > pCanv.height + 40) resetPlatformer();
                if (platPlayer.x > 560 && platPlayer.y < 120 && !gameState.platformerSolved) {
                    gameState.platformerSolved = true;
                    gameState.unlockedFlappy = true;
                    checkUnlocks();
                    document.getElementById('platformer-status').innerText = 'Niveau valid√© ‚úÖ';
                    document.getElementById('slot-result').innerText = 'Platformer r√©ussi, progression vers Flappy !';
                    rewardCompletion('platformer', 20, 'Platformer termin√©');
                }

                pCtx.fillStyle = '#0e1528'; pCtx.fillRect(0, 0, pCanv.width, pCanv.height);
                pCtx.fillStyle = '#34d399'; pCtx.fillRect(575, 52, 12, 48);
                pCtx.fillStyle = '#6b7280';
                platPlatforms.forEach(pl => pCtx.fillRect(pl.x, pl.y, pl.w, pl.h));
                pCtx.fillStyle = '#60a5fa';
                pCtx.fillRect(platPlayer.x, platPlayer.y, platPlayer.w, platPlayer.h);
            }
            requestAnimationFrame(platformerLoop);
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') platKeys.left = true;
            if (e.key === 'ArrowRight') platKeys.right = true;
            if (e.key === ' ' || e.code === 'Space') platKeys.jump = true;
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') platKeys.left = false;
            if (e.key === 'ArrowRight') platKeys.right = false;
            if (e.key === ' ' || e.code === 'Space') platKeys.jump = false;
        });

        // ==========================================
        // MINIGAME 2.9: MOTUS
        // ==========================================
        const motusWords = ['POMME','TABLE','NUAGE','FLEUR','ROBOT','TRAIN','PLAGE','CANAL','LIVRE','VAGUE'];
        let motusSecret = 'POMME';
        let motusAttempts = 0;
        let motusLog = [];

        function scoreMotusGuess(guess, secret) {
            const result = Array(5).fill('‚¨õ');
            const pool = secret.split('');
            guess.split('').forEach((ch, i) => {
                if (secret[i] === ch) { result[i] = 'üü©'; pool[i] = '_'; }
            });
            guess.split('').forEach((ch, i) => {
                if (result[i] === 'üü©') return;
                const idx = pool.indexOf(ch);
                if (idx >= 0) { result[i] = 'üü®'; pool[idx] = '_'; }
            });
            return result.join('');
        }

        function resetMotusRound() {
            motusSecret = motusWords[Math.floor(Math.random() * motusWords.length)];
            motusAttempts = 0;
            motusLog = [];
            document.getElementById('motus-status').innerText = 'Nouveau mot pr√™t';
            renderMotusHistory();
        }

        function renderMotusHistory() {
            const text = motusLog.length ? motusLog.join('\n') : 'Aucun essai pour le moment.';
            document.getElementById('motus-history').innerText = text;
        }

        function submitMotusGuess() {
            const input = document.getElementById('motus-input');
            const guess = (input.value || '').trim().toUpperCase();
            input.value = '';
            if (!/^[A-Z]{5}$/.test(guess)) {
                document.getElementById('motus-status').innerText = 'Entre un mot de 5 lettres.';
                return;
            }
            motusAttempts += 1;
            const score = scoreMotusGuess(guess, motusSecret);
            motusLog.push(`${guess} ${score}`);
            if (guess === motusSecret) {
                gameState.motusSolved = true;
                gameState.motusBest = Math.max(gameState.motusBest || 0, Math.max(0, 7 - motusAttempts));
                checkUnlocks();
                document.getElementById('motus-status').innerText = `Trouv√© en ${motusAttempts} essais ‚úÖ`;
                rewardCompletion('motus', 40, 'Motus gagn√©');
            } else if (motusAttempts >= 6) {
                document.getElementById('motus-status').innerText = `Perdu. Mot: ${motusSecret}`;
            } else {
                document.getElementById('motus-status').innerText = `Essai ${motusAttempts}/6`;
            }
            renderMotusHistory();
        }

        // ==========================================
        // BONUS: MACHINE A SOUS + ROULETTE + BLACKJACK
        // ==========================================
        const sCanv = document.getElementById('slot-canvas');
        const sCtx = sCanv.getContext('2d');
        const rCanv = document.getElementById('roulette-canvas');
        const rCtx = rCanv.getContext('2d');
        const slotSymbols = ['üçí', 'üçã', '7Ô∏è‚É£', 'üíé', 'üîî'];
        const rouletteNumbers = Array.from({ length: 37 }, (_, n) => ({
            n,
            color: n === 0 ? 'green' : ([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36].includes(n) ? 'red' : 'black')
        }));
        let rouletteAngle = 0;
        let rouletteBetType = 'red';
        let bjPlayer = [], bjDealer = [], bjDeck = [], bjDone = true, bjBet = 0;

        function getBetValue(inputId, min = 1) {
            const val = Number(document.getElementById(inputId).value);
            return Number.isFinite(val) ? Math.max(min, Math.floor(val)) : min;
        }

        function spendTokens(amount, msgId, gameName) {
            if (gameState.slotTokens < amount) {
                document.getElementById(msgId).innerText = `Pas assez de jetons pour ${gameName} (${amount} requis).`;
                return false;
            }
            gameState.slotTokens -= amount;
            checkUnlocks();
            return true;
        }

        function payoutTokens(amount) {
            gameState.slotTokens += amount;
            checkUnlocks();
        }

        function drawSlot(lastRoll = ['‚ùî', '‚ùî', '‚ùî']) {
            const grad = sCtx.createLinearGradient(0, 0, 0, sCanv.height);
            grad.addColorStop(0, '#120f29');
            grad.addColorStop(1, '#1f2b46');
            sCtx.fillStyle = grad;
            sCtx.fillRect(0, 0, sCanv.width, sCanv.height);
            sCtx.strokeStyle = 'rgba(3, 218, 198, 0.5)';
            sCtx.lineWidth = 2;
            sCtx.strokeRect(10, 10, 340, 145);
            sCtx.fillStyle = 'rgba(7, 14, 28, 0.85)';
            sCtx.fillRect(20, 25, 320, 120);
            lastRoll.forEach((sym, i) => {
                sCtx.fillStyle = '#111827';
                sCtx.fillRect(35 + i * 100, 40, 80, 90);
                sCtx.strokeStyle = '#3ddad7';
                sCtx.strokeRect(35 + i * 100, 40, 80, 90);
                sCtx.fillStyle = '#fff';
                sCtx.font = '45px sans-serif';
                sCtx.fillText(sym, 52 + i * 100, 99);
            });
            sCtx.fillStyle = '#8bf8ee';
            sCtx.font = '13px sans-serif';
            sCtx.fillText('3 symboles identiques = x5 | 2 identiques rares = x1.2 | sinon perdu', 22, 184);
        }

        function spinSlotMachine() {
            const bet = getBetValue('slot-bet');
            if (!spendTokens(bet, 'slot-result', 'la machine √† sous')) return;
            const roll = [0,0,0].map(() => slotSymbols[Math.floor(Math.random() * slotSymbols.length)]);
            drawSlot(roll);
            const uniq = new Set(roll).size;
            let multiplier = 0;
            if (uniq === 1) multiplier = 5;
            else if (uniq === 2 && Math.random() < 0.2) multiplier = 1.2;
            const gain = Math.floor(bet * multiplier);
            if (gain > 0) payoutTokens(gain);
            document.getElementById('slot-result').innerText = gain > 0 ? `R√©sultat ${roll.join(' ')}: x${multiplier.toFixed(1)}, +${gain} jetons` : `R√©sultat ${roll.join(' ')}: perdu.`;
        }

        function drawRoulette(pointer = null) {
            const bg = rCtx.createLinearGradient(0, 0, 0, rCanv.height);
            bg.addColorStop(0, '#111827');
            bg.addColorStop(1, '#1d2d4c');
            rCtx.fillStyle = bg;
            rCtx.fillRect(0, 0, rCanv.width, rCanv.height);
            const cx = 120, cy = 110, r = 86;
            const sliceAngle = (Math.PI * 2) / rouletteNumbers.length;
            rouletteNumbers.forEach((entry, i) => {
                const start = rouletteAngle + i * sliceAngle;
                rCtx.beginPath();
                rCtx.moveTo(cx, cy);
                rCtx.arc(cx, cy, r, start, start + sliceAngle);
                rCtx.closePath();
                rCtx.fillStyle = entry.color === 'red' ? '#dc2626' : entry.color === 'black' ? '#111827' : '#16a34a';
                rCtx.fill();
                const mid = start + (sliceAngle / 2);
                rCtx.save();
                rCtx.translate(cx + Math.cos(mid) * (r - 18), cy + Math.sin(mid) * (r - 18));
                rCtx.rotate(mid + Math.PI / 2);
                rCtx.fillStyle = '#fff';
                rCtx.font = '9px sans-serif';
                rCtx.fillText(String(entry.n), -6, 0);
                rCtx.restore();
            });
            rCtx.fillStyle = '#22d3ee';
            rCtx.beginPath();
            rCtx.moveTo(cx + r + 15, cy); rCtx.lineTo(cx + r + 35, cy - 10); rCtx.lineTo(cx + r + 35, cy + 10);
            rCtx.closePath();
            rCtx.fill();
            rCtx.font = '13px sans-serif';
            rCtx.fillText(`Mise: ${rouletteBetType.toUpperCase()}`, 225, 45);
            if (pointer !== null) {
                rCtx.fillText(`Num√©ro: ${rouletteNumbers[pointer].n} (${rouletteNumbers[pointer].color})`, 225, 72);
            }
        }

        function setRouletteBetType(type) {
            rouletteBetType = type;
            drawRoulette();
        }

        function rouletteWin(number, type) {
            if (type === 'red') return number.color === 'red';
            if (type === 'black') return number.color === 'black';
            if (type === 'even') return number.n !== 0 && number.n % 2 === 0;
            if (type === 'odd') return number.n % 2 === 1;
            return false;
        }

        function spinRoulette() {
            const bet = getBetValue('roulette-bet');
            if (!spendTokens(bet, 'roulette-result', 'la roulette')) return;
            const losingIndexes = rouletteNumbers.map((n, i) => ({ n, i })).filter(({ n }) => !rouletteWin(n, rouletteBetType)).map(({ i }) => i);
            const idx = (Math.random() < 0.65 && losingIndexes.length)
                ? losingIndexes[Math.floor(Math.random() * losingIndexes.length)]
                : Math.floor(Math.random() * rouletteNumbers.length);
            const sliceAngle = (Math.PI * 2) / rouletteNumbers.length;
            const targetAngle = (Math.PI * 8) + ((rouletteNumbers.length - idx) * sliceAngle);
            const startAngle = rouletteAngle;
            const startTime = performance.now();
            const duration = 1700;

            function animate(now) {
                const t = Math.min((now - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);
                rouletteAngle = startAngle + (targetAngle - startAngle) * eased;
                drawRoulette();
                if (t < 1) return requestAnimationFrame(animate);
                const number = rouletteNumbers[idx];
                const won = rouletteWin(number, rouletteBetType);
                if (won) payoutTokens(bet * 2);
                document.getElementById('roulette-result').innerText = won
                    ? `N¬∞${number.n} ${number.color}: gagn√© +${bet * 2} jetons (x2)`
                    : `N¬∞${number.n} ${number.color}: perdu.`;
                drawRoulette(idx);
            }
            requestAnimationFrame(animate);
        }

        const bCanv = document.getElementById('blackjack-canvas');
        const bCtx = bCanv.getContext('2d');

        function newDeck() {
            const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            bjDeck = [];
            for (let suit = 0; suit < 4; suit++) vals.forEach(v => bjDeck.push(v));
            bjDeck.sort(() => Math.random() - 0.5);
        }

        function handValue(hand) {
            let total = 0, aces = 0;
            hand.forEach(v => { if (v === 'A') { total += 11; aces++; } else if (['J','Q','K'].includes(v)) total += 10; else total += Number(v); });
            while (total > 21 && aces-- > 0) total -= 10;
            return total;
        }

        function drawBlackjack(revealDealer = false) {
            const felt = bCtx.createLinearGradient(0, 0, 0, bCanv.height);
            felt.addColorStop(0, '#0f5132');
            felt.addColorStop(1, '#06351f');
            bCtx.fillStyle = felt; bCtx.fillRect(0,0,bCanv.width,bCanv.height);
            bCtx.strokeStyle = 'rgba(255,215,0,0.45)';
            bCtx.strokeRect(8, 8, bCanv.width - 16, bCanv.height - 16);
            bCtx.fillStyle = '#fff'; bCtx.font = '13px sans-serif';
            bCtx.fillText(`Dealer: ${revealDealer ? handValue(bjDealer) : '?'}`, 10, 18);
            bCtx.fillText(`Player: ${handValue(bjPlayer)}`, 10, 128);
            bCtx.fillText(`Mise: ${bjBet}`, 255, 18);
            bjDealer.forEach((c, i) => drawCard(20 + i * 45, 28, revealDealer || i === 0 ? c : 'üÇ†'));
            bjPlayer.forEach((c, i) => drawCard(20 + i * 45, 140, c));
        }

        function drawCard(x, y, label) {
            bCtx.fillStyle = '#f8fafc'; bCtx.fillRect(x, y, 38, 56);
            bCtx.strokeStyle = '#111'; bCtx.strokeRect(x, y, 38, 56);
            bCtx.fillStyle = '#111'; bCtx.font = '14px sans-serif'; bCtx.fillText(label, x + 10, y + 32);
        }

        function startBlackjackRound() {
            if (!bjDone) return;
            bjBet = getBetValue('blackjack-bet');
            if (!spendTokens(bjBet, 'blackjack-result', 'le blackjack')) return;
            newDeck();
            bjPlayer = [bjDeck.pop(), bjDeck.pop()];
            bjDealer = [bjDeck.pop(), bjDeck.pop()];
            bjDone = false;
            document.getElementById('blackjack-result').innerText = 'Main en cours...';
            animateBlackjackReveal(0);
        }

        function animateBlackjackReveal(step) {
            drawBlackjack(false);
            if (step > 2) return;
            setTimeout(() => animateBlackjackReveal(step + 1), 120);
        }

        function blackjackHit() {
            if (bjDone) return;
            bjPlayer.push(bjDeck.pop());
            drawBlackjack(false);
            if (handValue(bjPlayer) > 21) finishBlackjack();
        }

        function blackjackStand() {
            if (bjDone) return;
            while (handValue(bjDealer) < 17) bjDealer.push(bjDeck.pop());
            finishBlackjack();
        }

        function finishBlackjack() {
            bjDone = true;
            const p = handValue(bjPlayer), d = handValue(bjDealer);
            let msg = '√âgalit√©.';
            if (p > 21) msg = 'Bust, perdu.';
            else if (d > 21 || p > d) { payoutTokens(bjBet * 2); msg = `Gagn√© ! +${bjBet * 2} jetons`; rewardCompletion('blackjackWin', 60, 'premi√®re victoire Blackjack'); }
            else if (p < d) msg = 'Perdu.';
            else { payoutTokens(bjBet); msg = `Push, mise rembours√©e (+${bjBet}).`; }
            document.getElementById('blackjack-result').innerText = msg;
            drawBlackjack(true);
        }


        function cardRank(value) {
            if (value === 'A') return 14;
            if (value === 'K') return 13;
            if (value === 'Q') return 12;
            if (value === 'J') return 11;
            return Number(value);
        }

        function handStrength(cards) {
            const ranks = cards.map(cardRank).sort((a, b) => b - a);
            const counts = {};
            ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
            const groups = Object.entries(counts).map(([rank, count]) => ({ rank: Number(rank), count }))
                .sort((a, b) => b.count - a.count || b.rank - a.rank);
            const score = groups[0].count === 3 ? 300 + groups[0].rank
                : groups[0].count === 2 ? 200 + groups[0].rank
                : 100 + ranks[0];
            return { score, groups, ranks };
        }

        function createPokerDeck() {
            const vals = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            const suits = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
            const deck = [];
            suits.forEach(suit => vals.forEach(v => deck.push(`${v}${suit}`)));
            return deck.sort(() => Math.random() - 0.5);
        }

        function renderPokerCards(containerId, cards = [], hidden = false) {
            const container = document.getElementById(containerId);
            if (!container) return;
            if (!cards.length) {
                container.innerHTML = '<div class="poker-card back">üÇ†</div><div class="poker-card back">üÇ†</div><div class="poker-card back">üÇ†</div><div class="poker-card back">üÇ†</div><div class="poker-card back">üÇ†</div>';
                return;
            }
            container.innerHTML = cards.map(card => {
                if (hidden) return '<div class="poker-card back">üÇ†</div>';
                const suit = card.slice(-1);
                const red = (suit === '‚ô•' || suit === '‚ô¶') ? ' red' : '';
                return `<div class="poker-card${red}">${card}</div>`;
            }).join('');
        }

        function playClassicPoker() {
            if (!gameState.unlockedPoker) {
                document.getElementById('poker-result').innerText = 'Poker classique verrouill√©.';
                return;
            }
            const bet = getBetValue('poker-bet');
            if (!spendTokens(bet, 'poker-result', 'le poker classique')) return;
            const deck = createPokerDeck();
            const player = deck.splice(0, 5).map(c => c.slice(0, -1));
            const dealer = deck.splice(0, 5).map(c => c.slice(0, -1));
            const ps = handStrength(player);
            const ds = handStrength(dealer);
            renderPokerCards('poker-hero', player);
            renderPokerCards('poker-dealer', dealer);
            if (ps.score > ds.score) {
                payoutTokens(bet * 2);
                document.getElementById('poker-result').innerText = `Main: ${player.join(' ')} | Banque: ${dealer.join(' ')} ‚Üí gagn√© +${bet * 2}`;
                rewardCompletion('classicPoker', 80, 'premi√®re victoire au poker classique');
            } else if (ps.score === ds.score) {
                payoutTokens(bet);
                document.getElementById('poker-result').innerText = `Main: ${player.join(' ')} | Banque: ${dealer.join(' ')} ‚Üí √©galit√©.`;
            } else {
                document.getElementById('poker-result').innerText = `Main: ${player.join(' ')} | Banque: ${dealer.join(' ')} ‚Üí perdu.`;
            }
        }

        renderPokerCards('poker-hero', []);
        renderPokerCards('poker-dealer', []);
        drawSlot();
        drawRoulette();
        drawBlackjack(false);

        // ==========================================
        // MINIGAME 3: SWARM SURVIVAL
        // ==========================================
        const dCanv = document.getElementById('dodge-canvas');
        const dCtx = dCanv.getContext('2d');
        let player = { x: 300, y: 200, size: 15 }, enemies = [], dTime = 0, lastTick = Date.now();

        function resetDodge(manual = false) {
            dTime = 0;
            enemies = [];
            player.x = 300;
            player.y = 200;
            document.getElementById('dodge-score').innerText = '0';

        }

        dCanv.addEventListener('mousemove', e => {
            const rect = dCanv.getBoundingClientRect();
            player.x = e.clientX - rect.left; player.y = e.clientY - rect.top;
        });

        function dodgeLoop() {
            if (currentActiveTab === 'screen-final') {
                const now = Date.now(); const dt = now - lastTick; lastTick = now;
                dTime += dt;
                document.getElementById('dodge-score').innerText = (dTime / 1000).toFixed(1);

                // Progressive, but fair, difficulty curve
                let spawnRate = 0.04 + (dTime / 30000) * 0.18;

                if(Math.random() < spawnRate) { 
                    let side = Math.floor(Math.random()*4);
                    let x = side%2===0 ? Math.random()*600 : (side===1?600:0);
                    let y = side%2!==0 ? Math.random()*400 : (side===0?0:400);
                    let angle = Math.atan2(player.y - y, player.x - x);
                    // Enemies become faster over time, but less aggressively
                    let speed = 2 + (dTime / 30000) * 1.6;
                    enemies.push({ x: x, y: y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, size: 8 });
                }

                dCtx.fillStyle = 'rgba(0,0,0,0.3)'; dCtx.fillRect(0,0,600,400); 
                dCtx.fillStyle = '#bb86fc'; dCtx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);

                for (let i = enemies.length-1; i >= 0; i--) {
                    let e = enemies[i];
                    e.x += e.vx; e.y += e.vy;
                    dCtx.fillStyle = '#cf6679'; dCtx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
                    
                    // Hit detection
                    let dist = Math.hypot(player.x - e.x, player.y - e.y);
                    if (dist < (player.size/2 + e.size/2)) {
                        triggerRetroDeathPopup('Swarm Survival');
                        resetDodge();
                        break;
                    }
                    if (e.x < -50 || e.x > 650 || e.y < -50 || e.y > 450) enemies.splice(i, 1);
                }

                if (dTime >= 30000) {
                    alert("YOU DID IT! You survived the swarm and beat the game!");
                    rewardCompletion('swarm', 10, 'Swarm Survival termin√©');
                    resetDodge();
                }
            } else { lastTick = Date.now(); } 
            requestAnimationFrame(dodgeLoop);
        }

        function varColor(name) { return getComputedStyle(document.body).getPropertyValue(name); }
    </script>
</body>
</html>
